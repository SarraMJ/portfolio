"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/astring";
exports.ids = ["vendor-chunks/astring"];
exports.modules = {

/***/ "(rsc)/./node_modules/astring/dist/astring.mjs":
/*!***********************************************!*\
  !*** ./node_modules/astring/dist/astring.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXPRESSIONS_PRECEDENCE: () => (/* binding */ EXPRESSIONS_PRECEDENCE),\n/* harmony export */   GENERATOR: () => (/* binding */ GENERATOR),\n/* harmony export */   NEEDS_PARENTHESES: () => (/* binding */ NEEDS_PARENTHESES),\n/* harmony export */   baseGenerator: () => (/* binding */ baseGenerator),\n/* harmony export */   generate: () => (/* binding */ generate)\n/* harmony export */ });\n// Astring is a tiny and fast JavaScript code generator from an ESTree-compliant AST.\n//\n// Astring was written by David Bonnet and released under an MIT license.\n//\n// The Git repository for Astring is available at:\n// https://github.com/davidbonnet/astring.git\n//\n// Please use the GitHub bug tracker to report issues:\n// https://github.com/davidbonnet/astring/issues\n\nconst { stringify } = JSON\n\n/* c8 ignore if */\nif (!String.prototype.repeat) {\n  /* c8 ignore next */\n  throw new Error(\n    'String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation',\n  )\n}\n\n/* c8 ignore if */\nif (!String.prototype.endsWith) {\n  /* c8 ignore next */\n  throw new Error(\n    'String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation',\n  )\n}\n\nconst OPERATOR_PRECEDENCE = {\n  '||': 2,\n  '??': 3,\n  '&&': 4,\n  '|': 5,\n  '^': 6,\n  '&': 7,\n  '==': 8,\n  '!=': 8,\n  '===': 8,\n  '!==': 8,\n  '<': 9,\n  '>': 9,\n  '<=': 9,\n  '>=': 9,\n  in: 9,\n  instanceof: 9,\n  '<<': 10,\n  '>>': 10,\n  '>>>': 10,\n  '+': 11,\n  '-': 11,\n  '*': 12,\n  '%': 12,\n  '/': 12,\n  '**': 13,\n}\n\n// Enables parenthesis regardless of precedence\nconst NEEDS_PARENTHESES = 17\n\nconst EXPRESSIONS_PRECEDENCE = {\n  // Definitions\n  ArrayExpression: 20,\n  TaggedTemplateExpression: 20,\n  ThisExpression: 20,\n  Identifier: 20,\n  PrivateIdentifier: 20,\n  Literal: 18,\n  TemplateLiteral: 20,\n  Super: 20,\n  SequenceExpression: 20,\n  // Operations\n  MemberExpression: 19,\n  ChainExpression: 19,\n  CallExpression: 19,\n  NewExpression: 19,\n  // Other definitions\n  ArrowFunctionExpression: NEEDS_PARENTHESES,\n  ClassExpression: NEEDS_PARENTHESES,\n  FunctionExpression: NEEDS_PARENTHESES,\n  ObjectExpression: NEEDS_PARENTHESES,\n  // Other operations\n  UpdateExpression: 16,\n  UnaryExpression: 15,\n  AwaitExpression: 15,\n  BinaryExpression: 14,\n  LogicalExpression: 13,\n  ConditionalExpression: 4,\n  AssignmentExpression: 3,\n  YieldExpression: 2,\n  RestElement: 1,\n}\n\nfunction formatSequence(state, nodes) {\n  /*\n  Writes into `state` a sequence of `nodes`.\n  */\n  const { generator } = state\n  state.write('(')\n  if (nodes != null && nodes.length > 0) {\n    generator[nodes[0].type](nodes[0], state)\n    const { length } = nodes\n    for (let i = 1; i < length; i++) {\n      const param = nodes[i]\n      state.write(', ')\n      generator[param.type](param, state)\n    }\n  }\n  state.write(')')\n}\n\nfunction expressionNeedsParenthesis(state, node, parentNode, isRightHand) {\n  const nodePrecedence = state.expressionsPrecedence[node.type]\n  if (nodePrecedence === NEEDS_PARENTHESES) {\n    return true\n  }\n  const parentNodePrecedence = state.expressionsPrecedence[parentNode.type]\n  if (nodePrecedence !== parentNodePrecedence) {\n    // Different node types\n    return (\n      (!isRightHand &&\n        nodePrecedence === 15 &&\n        parentNodePrecedence === 14 &&\n        parentNode.operator === '**') ||\n      nodePrecedence < parentNodePrecedence\n    )\n  }\n  if (nodePrecedence !== 13 && nodePrecedence !== 14) {\n    // Not a `LogicalExpression` or `BinaryExpression`\n    return false\n  }\n  if (node.operator === '**' && parentNode.operator === '**') {\n    // Exponentiation operator has right-to-left associativity\n    return !isRightHand\n  }\n  if (\n    nodePrecedence === 13 &&\n    parentNodePrecedence === 13 &&\n    (node.operator === '??' || parentNode.operator === '??')\n  ) {\n    // Nullish coalescing and boolean operators cannot be combined\n    return true\n  }\n  if (isRightHand) {\n    // Parenthesis are used if both operators have the same precedence\n    return (\n      OPERATOR_PRECEDENCE[node.operator] <=\n      OPERATOR_PRECEDENCE[parentNode.operator]\n    )\n  }\n  return (\n    OPERATOR_PRECEDENCE[node.operator] <\n    OPERATOR_PRECEDENCE[parentNode.operator]\n  )\n}\n\nfunction formatExpression(state, node, parentNode, isRightHand) {\n  /*\n  Writes into `state` the provided `node`, adding parenthesis around if the provided `parentNode` needs it. If `node` is a right-hand argument, the provided `isRightHand` parameter should be `true`.\n  */\n  const { generator } = state\n  if (expressionNeedsParenthesis(state, node, parentNode, isRightHand)) {\n    state.write('(')\n    generator[node.type](node, state)\n    state.write(')')\n  } else {\n    generator[node.type](node, state)\n  }\n}\n\nfunction reindent(state, text, indent, lineEnd) {\n  /*\n  Writes into `state` the `text` string reindented with the provided `indent`.\n  */\n  const lines = text.split('\\n')\n  const end = lines.length - 1\n  state.write(lines[0].trim())\n  if (end > 0) {\n    state.write(lineEnd)\n    for (let i = 1; i < end; i++) {\n      state.write(indent + lines[i].trim() + lineEnd)\n    }\n    state.write(indent + lines[end].trim())\n  }\n}\n\nfunction formatComments(state, comments, indent, lineEnd) {\n  /*\n  Writes into `state` the provided list of `comments`, with the given `indent` and `lineEnd` strings.\n  Line comments will end with `\"\\n\"` regardless of the value of `lineEnd`.\n  Expects to start on a new unindented line.\n  */\n  const { length } = comments\n  for (let i = 0; i < length; i++) {\n    const comment = comments[i]\n    state.write(indent)\n    if (comment.type[0] === 'L') {\n      // Line comment\n      state.write('// ' + comment.value.trim() + '\\n', comment)\n    } else {\n      // Block comment\n      state.write('/*')\n      reindent(state, comment.value, indent, lineEnd)\n      state.write('*/' + lineEnd)\n    }\n  }\n}\n\nfunction hasCallExpression(node) {\n  /*\n  Returns `true` if the provided `node` contains a call expression and `false` otherwise.\n  */\n  let currentNode = node\n  while (currentNode != null) {\n    const { type } = currentNode\n    if (type[0] === 'C' && type[1] === 'a') {\n      // Is CallExpression\n      return true\n    } else if (type[0] === 'M' && type[1] === 'e' && type[2] === 'm') {\n      // Is MemberExpression\n      currentNode = currentNode.object\n    } else {\n      return false\n    }\n  }\n}\n\nfunction formatVariableDeclaration(state, node) {\n  /*\n  Writes into `state` a variable declaration.\n  */\n  const { generator } = state\n  const { declarations } = node\n  state.write(node.kind + ' ')\n  const { length } = declarations\n  if (length > 0) {\n    generator.VariableDeclarator(declarations[0], state)\n    for (let i = 1; i < length; i++) {\n      state.write(', ')\n      generator.VariableDeclarator(declarations[i], state)\n    }\n  }\n}\n\nlet ForInStatement,\n  FunctionDeclaration,\n  RestElement,\n  BinaryExpression,\n  ArrayExpression,\n  BlockStatement\n\nconst GENERATOR = {\n  /*\n  Default generator.\n  */\n  Program(node, state) {\n    const indent = state.indent.repeat(state.indentLevel)\n    const { lineEnd, writeComments } = state\n    if (writeComments && node.comments != null) {\n      formatComments(state, node.comments, indent, lineEnd)\n    }\n    const statements = node.body\n    const { length } = statements\n    for (let i = 0; i < length; i++) {\n      const statement = statements[i]\n      if (writeComments && statement.comments != null) {\n        formatComments(state, statement.comments, indent, lineEnd)\n      }\n      state.write(indent)\n      this[statement.type](statement, state)\n      state.write(lineEnd)\n    }\n    if (writeComments && node.trailingComments != null) {\n      formatComments(state, node.trailingComments, indent, lineEnd)\n    }\n  },\n  BlockStatement: (BlockStatement = function (node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    const statementIndent = indent + state.indent\n    state.write('{')\n    const statements = node.body\n    if (statements != null && statements.length > 0) {\n      state.write(lineEnd)\n      if (writeComments && node.comments != null) {\n        formatComments(state, node.comments, statementIndent, lineEnd)\n      }\n      const { length } = statements\n      for (let i = 0; i < length; i++) {\n        const statement = statements[i]\n        if (writeComments && statement.comments != null) {\n          formatComments(state, statement.comments, statementIndent, lineEnd)\n        }\n        state.write(statementIndent)\n        this[statement.type](statement, state)\n        state.write(lineEnd)\n      }\n      state.write(indent)\n    } else {\n      if (writeComments && node.comments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.comments, statementIndent, lineEnd)\n        state.write(indent)\n      }\n    }\n    if (writeComments && node.trailingComments != null) {\n      formatComments(state, node.trailingComments, statementIndent, lineEnd)\n    }\n    state.write('}')\n    state.indentLevel--\n  }),\n  ClassBody: BlockStatement,\n  StaticBlock(node, state) {\n    state.write('static ')\n    this.BlockStatement(node, state)\n  },\n  EmptyStatement(node, state) {\n    state.write(';')\n  },\n  ExpressionStatement(node, state) {\n    const precedence = state.expressionsPrecedence[node.expression.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      (precedence === 3 && node.expression.left.type[0] === 'O')\n    ) {\n      // Should always have parentheses or is an AssignmentExpression to an ObjectPattern\n      state.write('(')\n      this[node.expression.type](node.expression, state)\n      state.write(')')\n    } else {\n      this[node.expression.type](node.expression, state)\n    }\n    state.write(';')\n  },\n  IfStatement(node, state) {\n    state.write('if (')\n    this[node.test.type](node.test, state)\n    state.write(') ')\n    this[node.consequent.type](node.consequent, state)\n    if (node.alternate != null) {\n      state.write(' else ')\n      this[node.alternate.type](node.alternate, state)\n    }\n  },\n  LabeledStatement(node, state) {\n    this[node.label.type](node.label, state)\n    state.write(': ')\n    this[node.body.type](node.body, state)\n  },\n  BreakStatement(node, state) {\n    state.write('break')\n    if (node.label != null) {\n      state.write(' ')\n      this[node.label.type](node.label, state)\n    }\n    state.write(';')\n  },\n  ContinueStatement(node, state) {\n    state.write('continue')\n    if (node.label != null) {\n      state.write(' ')\n      this[node.label.type](node.label, state)\n    }\n    state.write(';')\n  },\n  WithStatement(node, state) {\n    state.write('with (')\n    this[node.object.type](node.object, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  SwitchStatement(node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    state.indentLevel++\n    const caseIndent = indent + state.indent\n    const statementIndent = caseIndent + state.indent\n    state.write('switch (')\n    this[node.discriminant.type](node.discriminant, state)\n    state.write(') {' + lineEnd)\n    const { cases: occurences } = node\n    const { length: occurencesCount } = occurences\n    for (let i = 0; i < occurencesCount; i++) {\n      const occurence = occurences[i]\n      if (writeComments && occurence.comments != null) {\n        formatComments(state, occurence.comments, caseIndent, lineEnd)\n      }\n      if (occurence.test) {\n        state.write(caseIndent + 'case ')\n        this[occurence.test.type](occurence.test, state)\n        state.write(':' + lineEnd)\n      } else {\n        state.write(caseIndent + 'default:' + lineEnd)\n      }\n      const { consequent } = occurence\n      const { length: consequentCount } = consequent\n      for (let i = 0; i < consequentCount; i++) {\n        const statement = consequent[i]\n        if (writeComments && statement.comments != null) {\n          formatComments(state, statement.comments, statementIndent, lineEnd)\n        }\n        state.write(statementIndent)\n        this[statement.type](statement, state)\n        state.write(lineEnd)\n      }\n    }\n    state.indentLevel -= 2\n    state.write(indent + '}')\n  },\n  ReturnStatement(node, state) {\n    state.write('return')\n    if (node.argument) {\n      state.write(' ')\n      this[node.argument.type](node.argument, state)\n    }\n    state.write(';')\n  },\n  ThrowStatement(node, state) {\n    state.write('throw ')\n    this[node.argument.type](node.argument, state)\n    state.write(';')\n  },\n  TryStatement(node, state) {\n    state.write('try ')\n    this[node.block.type](node.block, state)\n    if (node.handler) {\n      const { handler } = node\n      if (handler.param == null) {\n        state.write(' catch ')\n      } else {\n        state.write(' catch (')\n        this[handler.param.type](handler.param, state)\n        state.write(') ')\n      }\n      this[handler.body.type](handler.body, state)\n    }\n    if (node.finalizer) {\n      state.write(' finally ')\n      this[node.finalizer.type](node.finalizer, state)\n    }\n  },\n  WhileStatement(node, state) {\n    state.write('while (')\n    this[node.test.type](node.test, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  DoWhileStatement(node, state) {\n    state.write('do ')\n    this[node.body.type](node.body, state)\n    state.write(' while (')\n    this[node.test.type](node.test, state)\n    state.write(');')\n  },\n  ForStatement(node, state) {\n    state.write('for (')\n    if (node.init != null) {\n      const { init } = node\n      if (init.type[0] === 'V') {\n        formatVariableDeclaration(state, init)\n      } else {\n        this[init.type](init, state)\n      }\n    }\n    state.write('; ')\n    if (node.test) {\n      this[node.test.type](node.test, state)\n    }\n    state.write('; ')\n    if (node.update) {\n      this[node.update.type](node.update, state)\n    }\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  ForInStatement: (ForInStatement = function (node, state) {\n    state.write(`for ${node.await ? 'await ' : ''}(`)\n    const { left } = node\n    if (left.type[0] === 'V') {\n      formatVariableDeclaration(state, left)\n    } else {\n      this[left.type](left, state)\n    }\n    // Identifying whether node.type is `ForInStatement` or `ForOfStatement`\n    state.write(node.type[3] === 'I' ? ' in ' : ' of ')\n    this[node.right.type](node.right, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  }),\n  ForOfStatement: ForInStatement,\n  DebuggerStatement(node, state) {\n    state.write('debugger;', node)\n  },\n  FunctionDeclaration: (FunctionDeclaration = function (node, state) {\n    state.write(\n      (node.async ? 'async ' : '') +\n        (node.generator ? 'function* ' : 'function ') +\n        (node.id ? node.id.name : ''),\n      node,\n    )\n    formatSequence(state, node.params)\n    state.write(' ')\n    this[node.body.type](node.body, state)\n  }),\n  FunctionExpression: FunctionDeclaration,\n  VariableDeclaration(node, state) {\n    formatVariableDeclaration(state, node)\n    state.write(';')\n  },\n  VariableDeclarator(node, state) {\n    this[node.id.type](node.id, state)\n    if (node.init != null) {\n      state.write(' = ')\n      this[node.init.type](node.init, state)\n    }\n  },\n  ClassDeclaration(node, state) {\n    state.write('class ' + (node.id ? `${node.id.name} ` : ''), node)\n    if (node.superClass) {\n      state.write('extends ')\n      const { superClass } = node\n      const { type } = superClass\n      const precedence = state.expressionsPrecedence[type]\n      if (\n        (type[0] !== 'C' || type[1] !== 'l' || type[5] !== 'E') &&\n        (precedence === NEEDS_PARENTHESES ||\n          precedence < state.expressionsPrecedence.ClassExpression)\n      ) {\n        // Not a ClassExpression that needs parentheses\n        state.write('(')\n        this[node.superClass.type](superClass, state)\n        state.write(')')\n      } else {\n        this[superClass.type](superClass, state)\n      }\n      state.write(' ')\n    }\n    this.ClassBody(node.body, state)\n  },\n  ImportDeclaration(node, state) {\n    state.write('import ')\n    const { specifiers, attributes } = node\n    const { length } = specifiers\n    // TODO: Once babili is fixed, put this after condition\n    // https://github.com/babel/babili/issues/430\n    let i = 0\n    if (length > 0) {\n      for (; i < length; ) {\n        if (i > 0) {\n          state.write(', ')\n        }\n        const specifier = specifiers[i]\n        const type = specifier.type[6]\n        if (type === 'D') {\n          // ImportDefaultSpecifier\n          state.write(specifier.local.name, specifier)\n          i++\n        } else if (type === 'N') {\n          // ImportNamespaceSpecifier\n          state.write('* as ' + specifier.local.name, specifier)\n          i++\n        } else {\n          // ImportSpecifier\n          break\n        }\n      }\n      if (i < length) {\n        state.write('{')\n        for (;;) {\n          const specifier = specifiers[i]\n          const { name } = specifier.imported\n          state.write(name, specifier)\n          if (name !== specifier.local.name) {\n            state.write(' as ' + specifier.local.name)\n          }\n          if (++i < length) {\n            state.write(', ')\n          } else {\n            break\n          }\n        }\n        state.write('}')\n      }\n      state.write(' from ')\n    }\n    this.Literal(node.source, state)\n\n    if (attributes && attributes.length > 0) {\n      state.write(' with { ')\n      for (let i = 0; i < attributes.length; i++) {\n        this.ImportAttribute(attributes[i], state)\n        if (i < attributes.length - 1) state.write(', ')\n      }\n\n      state.write(' }')\n    }\n    state.write(';')\n  },\n  ImportAttribute(node, state) {\n    this.Identifier(node.key, state)\n    state.write(': ')\n    this.Literal(node.value, state)\n  },\n  ImportExpression(node, state) {\n    state.write('import(')\n    this[node.source.type](node.source, state)\n    state.write(')')\n  },\n  ExportDefaultDeclaration(node, state) {\n    state.write('export default ')\n    this[node.declaration.type](node.declaration, state)\n    if (\n      state.expressionsPrecedence[node.declaration.type] != null &&\n      node.declaration.type[0] !== 'F'\n    ) {\n      // All expression nodes except `FunctionExpression`\n      state.write(';')\n    }\n  },\n  ExportNamedDeclaration(node, state) {\n    state.write('export ')\n    if (node.declaration) {\n      this[node.declaration.type](node.declaration, state)\n    } else {\n      state.write('{')\n      const { specifiers } = node,\n        { length } = specifiers\n      if (length > 0) {\n        for (let i = 0; ; ) {\n          const specifier = specifiers[i]\n          const { name } = specifier.local\n          state.write(name, specifier)\n          if (name !== specifier.exported.name) {\n            state.write(' as ' + specifier.exported.name)\n          }\n          if (++i < length) {\n            state.write(', ')\n          } else {\n            break\n          }\n        }\n      }\n      state.write('}')\n      if (node.source) {\n        state.write(' from ')\n        this.Literal(node.source, state)\n      }\n\n      if (node.attributes && node.attributes.length > 0) {\n        state.write(' with { ')\n        for (let i = 0; i < node.attributes.length; i++) {\n          this.ImportAttribute(node.attributes[i], state)\n          if (i < node.attributes.length - 1) state.write(', ')\n        }\n\n        state.write(' }')\n      }\n\n      state.write(';')\n    }\n  },\n  ExportAllDeclaration(node, state) {\n    if (node.exported != null) {\n      state.write('export * as ' + node.exported.name + ' from ')\n    } else {\n      state.write('export * from ')\n    }\n    this.Literal(node.source, state)\n\n    if (node.attributes && node.attributes.length > 0) {\n      state.write(' with { ')\n      for (let i = 0; i < node.attributes.length; i++) {\n        this.ImportAttribute(node.attributes[i], state)\n        if (i < node.attributes.length - 1) state.write(', ')\n      }\n\n      state.write(' }')\n    }\n\n    state.write(';')\n  },\n  MethodDefinition(node, state) {\n    if (node.static) {\n      state.write('static ')\n    }\n    const kind = node.kind[0]\n    if (kind === 'g' || kind === 's') {\n      // Getter or setter\n      state.write(node.kind + ' ')\n    }\n    if (node.value.async) {\n      state.write('async ')\n    }\n    if (node.value.generator) {\n      state.write('*')\n    }\n    if (node.computed) {\n      state.write('[')\n      this[node.key.type](node.key, state)\n      state.write(']')\n    } else {\n      this[node.key.type](node.key, state)\n    }\n    formatSequence(state, node.value.params)\n    state.write(' ')\n    this[node.value.body.type](node.value.body, state)\n  },\n  ClassExpression(node, state) {\n    this.ClassDeclaration(node, state)\n  },\n  ArrowFunctionExpression(node, state) {\n    state.write(node.async ? 'async ' : '', node)\n    const { params } = node\n    if (params != null) {\n      // Omit parenthesis if only one named parameter\n      if (params.length === 1 && params[0].type[0] === 'I') {\n        // If params[0].type[0] starts with 'I', it can't be `ImportDeclaration` nor `IfStatement` and thus is `Identifier`\n        state.write(params[0].name, params[0])\n      } else {\n        formatSequence(state, node.params)\n      }\n    }\n    state.write(' => ')\n    if (node.body.type[0] === 'O') {\n      // Body is an object expression\n      state.write('(')\n      this.ObjectExpression(node.body, state)\n      state.write(')')\n    } else {\n      this[node.body.type](node.body, state)\n    }\n  },\n  ThisExpression(node, state) {\n    state.write('this', node)\n  },\n  Super(node, state) {\n    state.write('super', node)\n  },\n  RestElement: (RestElement = function (node, state) {\n    state.write('...')\n    this[node.argument.type](node.argument, state)\n  }),\n  SpreadElement: RestElement,\n  YieldExpression(node, state) {\n    state.write(node.delegate ? 'yield*' : 'yield')\n    if (node.argument) {\n      state.write(' ')\n      this[node.argument.type](node.argument, state)\n    }\n  },\n  AwaitExpression(node, state) {\n    state.write('await ', node)\n    formatExpression(state, node.argument, node)\n  },\n  TemplateLiteral(node, state) {\n    const { quasis, expressions } = node\n    state.write('`')\n    const { length } = expressions\n    for (let i = 0; i < length; i++) {\n      const expression = expressions[i]\n      const quasi = quasis[i]\n      state.write(quasi.value.raw, quasi)\n      state.write('${')\n      this[expression.type](expression, state)\n      state.write('}')\n    }\n    const quasi = quasis[quasis.length - 1]\n    state.write(quasi.value.raw, quasi)\n    state.write('`')\n  },\n  TemplateElement(node, state) {\n    state.write(node.value.raw, node)\n  },\n  TaggedTemplateExpression(node, state) {\n    formatExpression(state, node.tag, node)\n    this[node.quasi.type](node.quasi, state)\n  },\n  ArrayExpression: (ArrayExpression = function (node, state) {\n    state.write('[')\n    if (node.elements.length > 0) {\n      const { elements } = node,\n        { length } = elements\n      for (let i = 0; ; ) {\n        const element = elements[i]\n        if (element != null) {\n          this[element.type](element, state)\n        }\n        if (++i < length) {\n          state.write(', ')\n        } else {\n          if (element == null) {\n            state.write(', ')\n          }\n          break\n        }\n      }\n    }\n    state.write(']')\n  }),\n  ArrayPattern: ArrayExpression,\n  ObjectExpression(node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    const propertyIndent = indent + state.indent\n    state.write('{')\n    if (node.properties.length > 0) {\n      state.write(lineEnd)\n      if (writeComments && node.comments != null) {\n        formatComments(state, node.comments, propertyIndent, lineEnd)\n      }\n      const comma = ',' + lineEnd\n      const { properties } = node,\n        { length } = properties\n      for (let i = 0; ; ) {\n        const property = properties[i]\n        if (writeComments && property.comments != null) {\n          formatComments(state, property.comments, propertyIndent, lineEnd)\n        }\n        state.write(propertyIndent)\n        this[property.type](property, state)\n        if (++i < length) {\n          state.write(comma)\n        } else {\n          break\n        }\n      }\n      state.write(lineEnd)\n      if (writeComments && node.trailingComments != null) {\n        formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n      }\n      state.write(indent + '}')\n    } else if (writeComments) {\n      if (node.comments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.comments, propertyIndent, lineEnd)\n        if (node.trailingComments != null) {\n          formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n        }\n        state.write(indent + '}')\n      } else if (node.trailingComments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n        state.write(indent + '}')\n      } else {\n        state.write('}')\n      }\n    } else {\n      state.write('}')\n    }\n    state.indentLevel--\n  },\n  Property(node, state) {\n    if (node.method || node.kind[0] !== 'i') {\n      // Either a method or of kind `set` or `get` (not `init`)\n      this.MethodDefinition(node, state)\n    } else {\n      if (!node.shorthand) {\n        if (node.computed) {\n          state.write('[')\n          this[node.key.type](node.key, state)\n          state.write(']')\n        } else {\n          this[node.key.type](node.key, state)\n        }\n        state.write(': ')\n      }\n      this[node.value.type](node.value, state)\n    }\n  },\n  PropertyDefinition(node, state) {\n    if (node.static) {\n      state.write('static ')\n    }\n    if (node.computed) {\n      state.write('[')\n    }\n    this[node.key.type](node.key, state)\n    if (node.computed) {\n      state.write(']')\n    }\n    if (node.value == null) {\n      if (node.key.type[0] !== 'F') {\n        state.write(';')\n      }\n      return\n    }\n    state.write(' = ')\n    this[node.value.type](node.value, state)\n    state.write(';')\n  },\n  ObjectPattern(node, state) {\n    state.write('{')\n    if (node.properties.length > 0) {\n      const { properties } = node,\n        { length } = properties\n      for (let i = 0; ; ) {\n        this[properties[i].type](properties[i], state)\n        if (++i < length) {\n          state.write(', ')\n        } else {\n          break\n        }\n      }\n    }\n    state.write('}')\n  },\n  SequenceExpression(node, state) {\n    formatSequence(state, node.expressions)\n  },\n  UnaryExpression(node, state) {\n    if (node.prefix) {\n      const {\n        operator,\n        argument,\n        argument: { type },\n      } = node\n      state.write(operator)\n      const needsParentheses = expressionNeedsParenthesis(state, argument, node)\n      if (\n        !needsParentheses &&\n        (operator.length > 1 ||\n          (type[0] === 'U' &&\n            (type[1] === 'n' || type[1] === 'p') &&\n            argument.prefix &&\n            argument.operator[0] === operator &&\n            (operator === '+' || operator === '-')))\n      ) {\n        // Large operator or argument is UnaryExpression or UpdateExpression node\n        state.write(' ')\n      }\n      if (needsParentheses) {\n        state.write(operator.length > 1 ? ' (' : '(')\n        this[type](argument, state)\n        state.write(')')\n      } else {\n        this[type](argument, state)\n      }\n    } else {\n      // FIXME: This case never occurs\n      this[node.argument.type](node.argument, state)\n      state.write(node.operator)\n    }\n  },\n  UpdateExpression(node, state) {\n    // Always applied to identifiers or members, no parenthesis check needed\n    if (node.prefix) {\n      state.write(node.operator)\n      this[node.argument.type](node.argument, state)\n    } else {\n      this[node.argument.type](node.argument, state)\n      state.write(node.operator)\n    }\n  },\n  AssignmentExpression(node, state) {\n    this[node.left.type](node.left, state)\n    state.write(' ' + node.operator + ' ')\n    this[node.right.type](node.right, state)\n  },\n  AssignmentPattern(node, state) {\n    this[node.left.type](node.left, state)\n    state.write(' = ')\n    this[node.right.type](node.right, state)\n  },\n  BinaryExpression: (BinaryExpression = function (node, state) {\n    const isIn = node.operator === 'in'\n    if (isIn) {\n      // Avoids confusion in `for` loops initializers\n      state.write('(')\n    }\n    formatExpression(state, node.left, node, false)\n    state.write(' ' + node.operator + ' ')\n    formatExpression(state, node.right, node, true)\n    if (isIn) {\n      state.write(')')\n    }\n  }),\n  LogicalExpression: BinaryExpression,\n  ConditionalExpression(node, state) {\n    const { test } = node\n    const precedence = state.expressionsPrecedence[test.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence <= state.expressionsPrecedence.ConditionalExpression\n    ) {\n      state.write('(')\n      this[test.type](test, state)\n      state.write(')')\n    } else {\n      this[test.type](test, state)\n    }\n    state.write(' ? ')\n    this[node.consequent.type](node.consequent, state)\n    state.write(' : ')\n    this[node.alternate.type](node.alternate, state)\n  },\n  NewExpression(node, state) {\n    state.write('new ')\n    const precedence = state.expressionsPrecedence[node.callee.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.CallExpression ||\n      hasCallExpression(node.callee)\n    ) {\n      state.write('(')\n      this[node.callee.type](node.callee, state)\n      state.write(')')\n    } else {\n      this[node.callee.type](node.callee, state)\n    }\n    formatSequence(state, node['arguments'])\n  },\n  CallExpression(node, state) {\n    const precedence = state.expressionsPrecedence[node.callee.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.CallExpression\n    ) {\n      state.write('(')\n      this[node.callee.type](node.callee, state)\n      state.write(')')\n    } else {\n      this[node.callee.type](node.callee, state)\n    }\n    if (node.optional) {\n      state.write('?.')\n    }\n    formatSequence(state, node['arguments'])\n  },\n  ChainExpression(node, state) {\n    this[node.expression.type](node.expression, state)\n  },\n  MemberExpression(node, state) {\n    const precedence = state.expressionsPrecedence[node.object.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.MemberExpression\n    ) {\n      state.write('(')\n      this[node.object.type](node.object, state)\n      state.write(')')\n    } else {\n      this[node.object.type](node.object, state)\n    }\n    if (node.computed) {\n      if (node.optional) {\n        state.write('?.')\n      }\n      state.write('[')\n      this[node.property.type](node.property, state)\n      state.write(']')\n    } else {\n      if (node.optional) {\n        state.write('?.')\n      } else {\n        state.write('.')\n      }\n      this[node.property.type](node.property, state)\n    }\n  },\n  MetaProperty(node, state) {\n    state.write(node.meta.name + '.' + node.property.name, node)\n  },\n  Identifier(node, state) {\n    state.write(node.name, node)\n  },\n  PrivateIdentifier(node, state) {\n    state.write(`#${node.name}`, node)\n  },\n  Literal(node, state) {\n    if (node.raw != null) {\n      // Non-standard property\n      state.write(node.raw, node)\n    } else if (node.regex != null) {\n      this.RegExpLiteral(node, state)\n    } else if (node.bigint != null) {\n      state.write(node.bigint + 'n', node)\n    } else {\n      state.write(stringify(node.value), node)\n    }\n  },\n  RegExpLiteral(node, state) {\n    const { regex } = node\n    state.write(`/${regex.pattern}/${regex.flags}`, node)\n  },\n}\n\nconst EMPTY_OBJECT = {}\n\n/*\nDEPRECATED: Alternate export of `GENERATOR`.\n*/\nconst baseGenerator = GENERATOR\n\nclass State {\n  constructor(options) {\n    const setup = options == null ? EMPTY_OBJECT : options\n    this.output = ''\n    // Functional options\n    if (setup.output != null) {\n      this.output = setup.output\n      this.write = this.writeToStream\n    } else {\n      this.output = ''\n    }\n    this.generator = setup.generator != null ? setup.generator : GENERATOR\n    this.expressionsPrecedence =\n      setup.expressionsPrecedence != null\n        ? setup.expressionsPrecedence\n        : EXPRESSIONS_PRECEDENCE\n    // Formating setup\n    this.indent = setup.indent != null ? setup.indent : '  '\n    this.lineEnd = setup.lineEnd != null ? setup.lineEnd : '\\n'\n    this.indentLevel =\n      setup.startingIndentLevel != null ? setup.startingIndentLevel : 0\n    this.writeComments = setup.comments ? setup.comments : false\n    // Source map\n    if (setup.sourceMap != null) {\n      this.write =\n        setup.output == null ? this.writeAndMap : this.writeToStreamAndMap\n      this.sourceMap = setup.sourceMap\n      this.line = 1\n      this.column = 0\n      this.lineEndSize = this.lineEnd.split('\\n').length - 1\n      this.mapping = {\n        original: null,\n        // Uses the entire state to avoid generating ephemeral objects\n        generated: this,\n        name: undefined,\n        source: setup.sourceMap.file || setup.sourceMap._file,\n      }\n    }\n  }\n\n  write(code) {\n    this.output += code\n  }\n\n  writeToStream(code) {\n    this.output.write(code)\n  }\n\n  writeAndMap(code, node) {\n    this.output += code\n    this.map(code, node)\n  }\n\n  writeToStreamAndMap(code, node) {\n    this.output.write(code)\n    this.map(code, node)\n  }\n\n  map(code, node) {\n    if (node != null) {\n      const { type } = node\n      if (type[0] === 'L' && type[2] === 'n') {\n        // LineComment\n        this.column = 0\n        this.line++\n        return\n      }\n      if (node.loc != null) {\n        const { mapping } = this\n        mapping.original = node.loc.start\n        mapping.name = node.name\n        this.sourceMap.addMapping(mapping)\n      }\n      if (\n        (type[0] === 'T' && type[8] === 'E') ||\n        (type[0] === 'L' && type[1] === 'i' && typeof node.value === 'string')\n      ) {\n        // TemplateElement or Literal string node\n        const { length } = code\n        let { column, line } = this\n        for (let i = 0; i < length; i++) {\n          if (code[i] === '\\n') {\n            column = 0\n            line++\n          } else {\n            column++\n          }\n        }\n        this.column = column\n        this.line = line\n        return\n      }\n    }\n    const { length } = code\n    const { lineEnd } = this\n    if (length > 0) {\n      if (\n        this.lineEndSize > 0 &&\n        (lineEnd.length === 1\n          ? code[length - 1] === lineEnd\n          : code.endsWith(lineEnd))\n      ) {\n        this.line += this.lineEndSize\n        this.column = 0\n      } else {\n        this.column += length\n      }\n    }\n  }\n\n  toString() {\n    return this.output\n  }\n}\n\nfunction generate(node, options) {\n  /*\n  Returns a string representing the rendered code of the provided AST `node`.\n  The `options` are:\n\n  - `indent`: string to use for indentation (defaults to `␣␣`)\n  - `lineEnd`: string to use for line endings (defaults to `\\n`)\n  - `startingIndentLevel`: indent level to start from (defaults to `0`)\n  - `comments`: generate comments if `true` (defaults to `false`)\n  - `output`: output stream to write the rendered code to (defaults to `null`)\n  - `generator`: custom code generator (defaults to `GENERATOR`)\n  - `expressionsPrecedence`: custom map of node types and their precedence level (defaults to `EXPRESSIONS_PRECEDENCE`)\n  */\n  const state = new State(options)\n  // Travel through the AST node and generate the code\n  state.generator[node.type](node, state)\n  return state.output\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXN0cmluZy9kaXN0L2FzdHJpbmcubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsWUFBWTs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087O0FBRUE7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsY0FBYyxlQUFlO0FBQzdCLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQTQ3MDM0M1xcc291cmNlXFxmcm9udGVuZFxcemlhZHBvcnRmb2xpb1xcbm9kZV9tb2R1bGVzXFxhc3RyaW5nXFxkaXN0XFxhc3RyaW5nLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBc3RyaW5nIGlzIGEgdGlueSBhbmQgZmFzdCBKYXZhU2NyaXB0IGNvZGUgZ2VuZXJhdG9yIGZyb20gYW4gRVNUcmVlLWNvbXBsaWFudCBBU1QuXG4vL1xuLy8gQXN0cmluZyB3YXMgd3JpdHRlbiBieSBEYXZpZCBCb25uZXQgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVCBsaWNlbnNlLlxuLy9cbi8vIFRoZSBHaXQgcmVwb3NpdG9yeSBmb3IgQXN0cmluZyBpcyBhdmFpbGFibGUgYXQ6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGF2aWRib25uZXQvYXN0cmluZy5naXRcbi8vXG4vLyBQbGVhc2UgdXNlIHRoZSBHaXRIdWIgYnVnIHRyYWNrZXIgdG8gcmVwb3J0IGlzc3Vlczpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGJvbm5ldC9hc3RyaW5nL2lzc3Vlc1xuXG5jb25zdCB7IHN0cmluZ2lmeSB9ID0gSlNPTlxuXG4vKiBjOCBpZ25vcmUgaWYgKi9cbmlmICghU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQpIHtcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdTdHJpbmcucHJvdG90eXBlLnJlcGVhdCBpcyB1bmRlZmluZWQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZGF2aWRib25uZXQvYXN0cmluZyNpbnN0YWxsYXRpb24nLFxuICApXG59XG5cbi8qIGM4IGlnbm9yZSBpZiAqL1xuaWYgKCFTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKSB7XG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aCBpcyB1bmRlZmluZWQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZGF2aWRib25uZXQvYXN0cmluZyNpbnN0YWxsYXRpb24nLFxuICApXG59XG5cbmNvbnN0IE9QRVJBVE9SX1BSRUNFREVOQ0UgPSB7XG4gICd8fCc6IDIsXG4gICc/Pyc6IDMsXG4gICcmJic6IDQsXG4gICd8JzogNSxcbiAgJ14nOiA2LFxuICAnJic6IDcsXG4gICc9PSc6IDgsXG4gICchPSc6IDgsXG4gICc9PT0nOiA4LFxuICAnIT09JzogOCxcbiAgJzwnOiA5LFxuICAnPic6IDksXG4gICc8PSc6IDksXG4gICc+PSc6IDksXG4gIGluOiA5LFxuICBpbnN0YW5jZW9mOiA5LFxuICAnPDwnOiAxMCxcbiAgJz4+JzogMTAsXG4gICc+Pj4nOiAxMCxcbiAgJysnOiAxMSxcbiAgJy0nOiAxMSxcbiAgJyonOiAxMixcbiAgJyUnOiAxMixcbiAgJy8nOiAxMixcbiAgJyoqJzogMTMsXG59XG5cbi8vIEVuYWJsZXMgcGFyZW50aGVzaXMgcmVnYXJkbGVzcyBvZiBwcmVjZWRlbmNlXG5leHBvcnQgY29uc3QgTkVFRFNfUEFSRU5USEVTRVMgPSAxN1xuXG5leHBvcnQgY29uc3QgRVhQUkVTU0lPTlNfUFJFQ0VERU5DRSA9IHtcbiAgLy8gRGVmaW5pdGlvbnNcbiAgQXJyYXlFeHByZXNzaW9uOiAyMCxcbiAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiAyMCxcbiAgVGhpc0V4cHJlc3Npb246IDIwLFxuICBJZGVudGlmaWVyOiAyMCxcbiAgUHJpdmF0ZUlkZW50aWZpZXI6IDIwLFxuICBMaXRlcmFsOiAxOCxcbiAgVGVtcGxhdGVMaXRlcmFsOiAyMCxcbiAgU3VwZXI6IDIwLFxuICBTZXF1ZW5jZUV4cHJlc3Npb246IDIwLFxuICAvLyBPcGVyYXRpb25zXG4gIE1lbWJlckV4cHJlc3Npb246IDE5LFxuICBDaGFpbkV4cHJlc3Npb246IDE5LFxuICBDYWxsRXhwcmVzc2lvbjogMTksXG4gIE5ld0V4cHJlc3Npb246IDE5LFxuICAvLyBPdGhlciBkZWZpbml0aW9uc1xuICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogTkVFRFNfUEFSRU5USEVTRVMsXG4gIENsYXNzRXhwcmVzc2lvbjogTkVFRFNfUEFSRU5USEVTRVMsXG4gIEZ1bmN0aW9uRXhwcmVzc2lvbjogTkVFRFNfUEFSRU5USEVTRVMsXG4gIE9iamVjdEV4cHJlc3Npb246IE5FRURTX1BBUkVOVEhFU0VTLFxuICAvLyBPdGhlciBvcGVyYXRpb25zXG4gIFVwZGF0ZUV4cHJlc3Npb246IDE2LFxuICBVbmFyeUV4cHJlc3Npb246IDE1LFxuICBBd2FpdEV4cHJlc3Npb246IDE1LFxuICBCaW5hcnlFeHByZXNzaW9uOiAxNCxcbiAgTG9naWNhbEV4cHJlc3Npb246IDEzLFxuICBDb25kaXRpb25hbEV4cHJlc3Npb246IDQsXG4gIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAzLFxuICBZaWVsZEV4cHJlc3Npb246IDIsXG4gIFJlc3RFbGVtZW50OiAxLFxufVxuXG5mdW5jdGlvbiBmb3JtYXRTZXF1ZW5jZShzdGF0ZSwgbm9kZXMpIHtcbiAgLypcbiAgV3JpdGVzIGludG8gYHN0YXRlYCBhIHNlcXVlbmNlIG9mIGBub2Rlc2AuXG4gICovXG4gIGNvbnN0IHsgZ2VuZXJhdG9yIH0gPSBzdGF0ZVxuICBzdGF0ZS53cml0ZSgnKCcpXG4gIGlmIChub2RlcyAhPSBudWxsICYmIG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICBnZW5lcmF0b3Jbbm9kZXNbMF0udHlwZV0obm9kZXNbMF0sIHN0YXRlKVxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBub2Rlc1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcmFtID0gbm9kZXNbaV1cbiAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICBnZW5lcmF0b3JbcGFyYW0udHlwZV0ocGFyYW0sIHN0YXRlKVxuICAgIH1cbiAgfVxuICBzdGF0ZS53cml0ZSgnKScpXG59XG5cbmZ1bmN0aW9uIGV4cHJlc3Npb25OZWVkc1BhcmVudGhlc2lzKHN0YXRlLCBub2RlLCBwYXJlbnROb2RlLCBpc1JpZ2h0SGFuZCkge1xuICBjb25zdCBub2RlUHJlY2VkZW5jZSA9IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZVtub2RlLnR5cGVdXG4gIGlmIChub2RlUHJlY2VkZW5jZSA9PT0gTkVFRFNfUEFSRU5USEVTRVMpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGNvbnN0IHBhcmVudE5vZGVQcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW3BhcmVudE5vZGUudHlwZV1cbiAgaWYgKG5vZGVQcmVjZWRlbmNlICE9PSBwYXJlbnROb2RlUHJlY2VkZW5jZSkge1xuICAgIC8vIERpZmZlcmVudCBub2RlIHR5cGVzXG4gICAgcmV0dXJuIChcbiAgICAgICghaXNSaWdodEhhbmQgJiZcbiAgICAgICAgbm9kZVByZWNlZGVuY2UgPT09IDE1ICYmXG4gICAgICAgIHBhcmVudE5vZGVQcmVjZWRlbmNlID09PSAxNCAmJlxuICAgICAgICBwYXJlbnROb2RlLm9wZXJhdG9yID09PSAnKionKSB8fFxuICAgICAgbm9kZVByZWNlZGVuY2UgPCBwYXJlbnROb2RlUHJlY2VkZW5jZVxuICAgIClcbiAgfVxuICBpZiAobm9kZVByZWNlZGVuY2UgIT09IDEzICYmIG5vZGVQcmVjZWRlbmNlICE9PSAxNCkge1xuICAgIC8vIE5vdCBhIGBMb2dpY2FsRXhwcmVzc2lvbmAgb3IgYEJpbmFyeUV4cHJlc3Npb25gXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUub3BlcmF0b3IgPT09ICcqKicgJiYgcGFyZW50Tm9kZS5vcGVyYXRvciA9PT0gJyoqJykge1xuICAgIC8vIEV4cG9uZW50aWF0aW9uIG9wZXJhdG9yIGhhcyByaWdodC10by1sZWZ0IGFzc29jaWF0aXZpdHlcbiAgICByZXR1cm4gIWlzUmlnaHRIYW5kXG4gIH1cbiAgaWYgKFxuICAgIG5vZGVQcmVjZWRlbmNlID09PSAxMyAmJlxuICAgIHBhcmVudE5vZGVQcmVjZWRlbmNlID09PSAxMyAmJlxuICAgIChub2RlLm9wZXJhdG9yID09PSAnPz8nIHx8IHBhcmVudE5vZGUub3BlcmF0b3IgPT09ICc/PycpXG4gICkge1xuICAgIC8vIE51bGxpc2ggY29hbGVzY2luZyBhbmQgYm9vbGVhbiBvcGVyYXRvcnMgY2Fubm90IGJlIGNvbWJpbmVkXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSaWdodEhhbmQpIHtcbiAgICAvLyBQYXJlbnRoZXNpcyBhcmUgdXNlZCBpZiBib3RoIG9wZXJhdG9ycyBoYXZlIHRoZSBzYW1lIHByZWNlZGVuY2VcbiAgICByZXR1cm4gKFxuICAgICAgT1BFUkFUT1JfUFJFQ0VERU5DRVtub2RlLm9wZXJhdG9yXSA8PVxuICAgICAgT1BFUkFUT1JfUFJFQ0VERU5DRVtwYXJlbnROb2RlLm9wZXJhdG9yXVxuICAgIClcbiAgfVxuICByZXR1cm4gKFxuICAgIE9QRVJBVE9SX1BSRUNFREVOQ0Vbbm9kZS5vcGVyYXRvcl0gPFxuICAgIE9QRVJBVE9SX1BSRUNFREVOQ0VbcGFyZW50Tm9kZS5vcGVyYXRvcl1cbiAgKVxufVxuXG5mdW5jdGlvbiBmb3JtYXRFeHByZXNzaW9uKHN0YXRlLCBub2RlLCBwYXJlbnROb2RlLCBpc1JpZ2h0SGFuZCkge1xuICAvKlxuICBXcml0ZXMgaW50byBgc3RhdGVgIHRoZSBwcm92aWRlZCBgbm9kZWAsIGFkZGluZyBwYXJlbnRoZXNpcyBhcm91bmQgaWYgdGhlIHByb3ZpZGVkIGBwYXJlbnROb2RlYCBuZWVkcyBpdC4gSWYgYG5vZGVgIGlzIGEgcmlnaHQtaGFuZCBhcmd1bWVudCwgdGhlIHByb3ZpZGVkIGBpc1JpZ2h0SGFuZGAgcGFyYW1ldGVyIHNob3VsZCBiZSBgdHJ1ZWAuXG4gICovXG4gIGNvbnN0IHsgZ2VuZXJhdG9yIH0gPSBzdGF0ZVxuICBpZiAoZXhwcmVzc2lvbk5lZWRzUGFyZW50aGVzaXMoc3RhdGUsIG5vZGUsIHBhcmVudE5vZGUsIGlzUmlnaHRIYW5kKSkge1xuICAgIHN0YXRlLndyaXRlKCcoJylcbiAgICBnZW5lcmF0b3Jbbm9kZS50eXBlXShub2RlLCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnKScpXG4gIH0gZWxzZSB7XG4gICAgZ2VuZXJhdG9yW25vZGUudHlwZV0obm9kZSwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVpbmRlbnQoc3RhdGUsIHRleHQsIGluZGVudCwgbGluZUVuZCkge1xuICAvKlxuICBXcml0ZXMgaW50byBgc3RhdGVgIHRoZSBgdGV4dGAgc3RyaW5nIHJlaW5kZW50ZWQgd2l0aCB0aGUgcHJvdmlkZWQgYGluZGVudGAuXG4gICovXG4gIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJylcbiAgY29uc3QgZW5kID0gbGluZXMubGVuZ3RoIC0gMVxuICBzdGF0ZS53cml0ZShsaW5lc1swXS50cmltKCkpXG4gIGlmIChlbmQgPiAwKSB7XG4gICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICBzdGF0ZS53cml0ZShpbmRlbnQgKyBsaW5lc1tpXS50cmltKCkgKyBsaW5lRW5kKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZShpbmRlbnQgKyBsaW5lc1tlbmRdLnRyaW0oKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRDb21tZW50cyhzdGF0ZSwgY29tbWVudHMsIGluZGVudCwgbGluZUVuZCkge1xuICAvKlxuICBXcml0ZXMgaW50byBgc3RhdGVgIHRoZSBwcm92aWRlZCBsaXN0IG9mIGBjb21tZW50c2AsIHdpdGggdGhlIGdpdmVuIGBpbmRlbnRgIGFuZCBgbGluZUVuZGAgc3RyaW5ncy5cbiAgTGluZSBjb21tZW50cyB3aWxsIGVuZCB3aXRoIGBcIlxcblwiYCByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZiBgbGluZUVuZGAuXG4gIEV4cGVjdHMgdG8gc3RhcnQgb24gYSBuZXcgdW5pbmRlbnRlZCBsaW5lLlxuICAqL1xuICBjb25zdCB7IGxlbmd0aCB9ID0gY29tbWVudHNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvbW1lbnQgPSBjb21tZW50c1tpXVxuICAgIHN0YXRlLndyaXRlKGluZGVudClcbiAgICBpZiAoY29tbWVudC50eXBlWzBdID09PSAnTCcpIHtcbiAgICAgIC8vIExpbmUgY29tbWVudFxuICAgICAgc3RhdGUud3JpdGUoJy8vICcgKyBjb21tZW50LnZhbHVlLnRyaW0oKSArICdcXG4nLCBjb21tZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCbG9jayBjb21tZW50XG4gICAgICBzdGF0ZS53cml0ZSgnLyonKVxuICAgICAgcmVpbmRlbnQoc3RhdGUsIGNvbW1lbnQudmFsdWUsIGluZGVudCwgbGluZUVuZClcbiAgICAgIHN0YXRlLndyaXRlKCcqLycgKyBsaW5lRW5kKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gIC8qXG4gIFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm92aWRlZCBgbm9kZWAgY29udGFpbnMgYSBjYWxsIGV4cHJlc3Npb24gYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAqL1xuICBsZXQgY3VycmVudE5vZGUgPSBub2RlXG4gIHdoaWxlIChjdXJyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBjdXJyZW50Tm9kZVxuICAgIGlmICh0eXBlWzBdID09PSAnQycgJiYgdHlwZVsxXSA9PT0gJ2EnKSB7XG4gICAgICAvLyBJcyBDYWxsRXhwcmVzc2lvblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKHR5cGVbMF0gPT09ICdNJyAmJiB0eXBlWzFdID09PSAnZScgJiYgdHlwZVsyXSA9PT0gJ20nKSB7XG4gICAgICAvLyBJcyBNZW1iZXJFeHByZXNzaW9uXG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm9iamVjdFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0VmFyaWFibGVEZWNsYXJhdGlvbihzdGF0ZSwgbm9kZSkge1xuICAvKlxuICBXcml0ZXMgaW50byBgc3RhdGVgIGEgdmFyaWFibGUgZGVjbGFyYXRpb24uXG4gICovXG4gIGNvbnN0IHsgZ2VuZXJhdG9yIH0gPSBzdGF0ZVxuICBjb25zdCB7IGRlY2xhcmF0aW9ucyB9ID0gbm9kZVxuICBzdGF0ZS53cml0ZShub2RlLmtpbmQgKyAnICcpXG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBkZWNsYXJhdGlvbnNcbiAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICBnZW5lcmF0b3IuVmFyaWFibGVEZWNsYXJhdG9yKGRlY2xhcmF0aW9uc1swXSwgc3RhdGUpXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgc3RhdGUud3JpdGUoJywgJylcbiAgICAgIGdlbmVyYXRvci5WYXJpYWJsZURlY2xhcmF0b3IoZGVjbGFyYXRpb25zW2ldLCBzdGF0ZSlcbiAgICB9XG4gIH1cbn1cblxubGV0IEZvckluU3RhdGVtZW50LFxuICBGdW5jdGlvbkRlY2xhcmF0aW9uLFxuICBSZXN0RWxlbWVudCxcbiAgQmluYXJ5RXhwcmVzc2lvbixcbiAgQXJyYXlFeHByZXNzaW9uLFxuICBCbG9ja1N0YXRlbWVudFxuXG5leHBvcnQgY29uc3QgR0VORVJBVE9SID0ge1xuICAvKlxuICBEZWZhdWx0IGdlbmVyYXRvci5cbiAgKi9cbiAgUHJvZ3JhbShub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IGluZGVudCA9IHN0YXRlLmluZGVudC5yZXBlYXQoc3RhdGUuaW5kZW50TGV2ZWwpXG4gICAgY29uc3QgeyBsaW5lRW5kLCB3cml0ZUNvbW1lbnRzIH0gPSBzdGF0ZVxuICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUuY29tbWVudHMsIGluZGVudCwgbGluZUVuZClcbiAgICB9XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IG5vZGUuYm9keVxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBzdGF0ZW1lbnRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RhdGVtZW50ID0gc3RhdGVtZW50c1tpXVxuICAgICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgc3RhdGVtZW50LmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIHN0YXRlbWVudC5jb21tZW50cywgaW5kZW50LCBsaW5lRW5kKVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoaW5kZW50KVxuICAgICAgdGhpc1tzdGF0ZW1lbnQudHlwZV0oc3RhdGVtZW50LCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgfVxuICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIG5vZGUudHJhaWxpbmdDb21tZW50cyAhPSBudWxsKSB7XG4gICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS50cmFpbGluZ0NvbW1lbnRzLCBpbmRlbnQsIGxpbmVFbmQpXG4gICAgfVxuICB9LFxuICBCbG9ja1N0YXRlbWVudDogKEJsb2NrU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgaW5kZW50ID0gc3RhdGUuaW5kZW50LnJlcGVhdChzdGF0ZS5pbmRlbnRMZXZlbCsrKVxuICAgIGNvbnN0IHsgbGluZUVuZCwgd3JpdGVDb21tZW50cyB9ID0gc3RhdGVcbiAgICBjb25zdCBzdGF0ZW1lbnRJbmRlbnQgPSBpbmRlbnQgKyBzdGF0ZS5pbmRlbnRcbiAgICBzdGF0ZS53cml0ZSgneycpXG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IG5vZGUuYm9keVxuICAgIGlmIChzdGF0ZW1lbnRzICE9IG51bGwgJiYgc3RhdGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgbm9kZS5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLmNvbW1lbnRzLCBzdGF0ZW1lbnRJbmRlbnQsIGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gc3RhdGVtZW50c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzdGF0ZW1lbnQgPSBzdGF0ZW1lbnRzW2ldXG4gICAgICAgIGlmICh3cml0ZUNvbW1lbnRzICYmIHN0YXRlbWVudC5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIHN0YXRlbWVudC5jb21tZW50cywgc3RhdGVtZW50SW5kZW50LCBsaW5lRW5kKVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLndyaXRlKHN0YXRlbWVudEluZGVudClcbiAgICAgICAgdGhpc1tzdGF0ZW1lbnQudHlwZV0oc3RhdGVtZW50LCBzdGF0ZSlcbiAgICAgICAgc3RhdGUud3JpdGUobGluZUVuZClcbiAgICAgIH1cbiAgICAgIHN0YXRlLndyaXRlKGluZGVudClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgbm9kZS5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLmNvbW1lbnRzLCBzdGF0ZW1lbnRJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIHN0YXRlLndyaXRlKGluZGVudClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgbm9kZS50cmFpbGluZ0NvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLnRyYWlsaW5nQ29tbWVudHMsIHN0YXRlbWVudEluZGVudCwgbGluZUVuZClcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJ30nKVxuICAgIHN0YXRlLmluZGVudExldmVsLS1cbiAgfSksXG4gIENsYXNzQm9keTogQmxvY2tTdGF0ZW1lbnQsXG4gIFN0YXRpY0Jsb2NrKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3N0YXRpYyAnKVxuICAgIHRoaXMuQmxvY2tTdGF0ZW1lbnQobm9kZSwgc3RhdGUpXG4gIH0sXG4gIEVtcHR5U3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgcHJlY2VkZW5jZSA9IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZVtub2RlLmV4cHJlc3Npb24udHlwZV1cbiAgICBpZiAoXG4gICAgICBwcmVjZWRlbmNlID09PSBORUVEU19QQVJFTlRIRVNFUyB8fFxuICAgICAgKHByZWNlZGVuY2UgPT09IDMgJiYgbm9kZS5leHByZXNzaW9uLmxlZnQudHlwZVswXSA9PT0gJ08nKVxuICAgICkge1xuICAgICAgLy8gU2hvdWxkIGFsd2F5cyBoYXZlIHBhcmVudGhlc2VzIG9yIGlzIGFuIEFzc2lnbm1lbnRFeHByZXNzaW9uIHRvIGFuIE9iamVjdFBhdHRlcm5cbiAgICAgIHN0YXRlLndyaXRlKCcoJylcbiAgICAgIHRoaXNbbm9kZS5leHByZXNzaW9uLnR5cGVdKG5vZGUuZXhwcmVzc2lvbiwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbm9kZS5leHByZXNzaW9uLnR5cGVdKG5vZGUuZXhwcmVzc2lvbiwgc3RhdGUpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgSWZTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnaWYgKCcpXG4gICAgdGhpc1tub2RlLnRlc3QudHlwZV0obm9kZS50ZXN0LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnKSAnKVxuICAgIHRoaXNbbm9kZS5jb25zZXF1ZW50LnR5cGVdKG5vZGUuY29uc2VxdWVudCwgc3RhdGUpXG4gICAgaWYgKG5vZGUuYWx0ZXJuYXRlICE9IG51bGwpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgZWxzZSAnKVxuICAgICAgdGhpc1tub2RlLmFsdGVybmF0ZS50eXBlXShub2RlLmFsdGVybmF0ZSwgc3RhdGUpXG4gICAgfVxuICB9LFxuICBMYWJlbGVkU3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgdGhpc1tub2RlLmxhYmVsLnR5cGVdKG5vZGUubGFiZWwsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCc6ICcpXG4gICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgfSxcbiAgQnJlYWtTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnYnJlYWsnKVxuICAgIGlmIChub2RlLmxhYmVsICE9IG51bGwpIHtcbiAgICAgIHN0YXRlLndyaXRlKCcgJylcbiAgICAgIHRoaXNbbm9kZS5sYWJlbC50eXBlXShub2RlLmxhYmVsLCBzdGF0ZSlcbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBDb250aW51ZVN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdjb250aW51ZScpXG4gICAgaWYgKG5vZGUubGFiZWwgIT0gbnVsbCkge1xuICAgICAgc3RhdGUud3JpdGUoJyAnKVxuICAgICAgdGhpc1tub2RlLmxhYmVsLnR5cGVdKG5vZGUubGFiZWwsIHN0YXRlKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIFdpdGhTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnd2l0aCAoJylcbiAgICB0aGlzW25vZGUub2JqZWN0LnR5cGVdKG5vZGUub2JqZWN0LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnKSAnKVxuICAgIHRoaXNbbm9kZS5ib2R5LnR5cGVdKG5vZGUuYm9keSwgc3RhdGUpXG4gIH0sXG4gIFN3aXRjaFN0YXRlbWVudChub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IGluZGVudCA9IHN0YXRlLmluZGVudC5yZXBlYXQoc3RhdGUuaW5kZW50TGV2ZWwrKylcbiAgICBjb25zdCB7IGxpbmVFbmQsIHdyaXRlQ29tbWVudHMgfSA9IHN0YXRlXG4gICAgc3RhdGUuaW5kZW50TGV2ZWwrK1xuICAgIGNvbnN0IGNhc2VJbmRlbnQgPSBpbmRlbnQgKyBzdGF0ZS5pbmRlbnRcbiAgICBjb25zdCBzdGF0ZW1lbnRJbmRlbnQgPSBjYXNlSW5kZW50ICsgc3RhdGUuaW5kZW50XG4gICAgc3RhdGUud3JpdGUoJ3N3aXRjaCAoJylcbiAgICB0aGlzW25vZGUuZGlzY3JpbWluYW50LnR5cGVdKG5vZGUuZGlzY3JpbWluYW50LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnKSB7JyArIGxpbmVFbmQpXG4gICAgY29uc3QgeyBjYXNlczogb2NjdXJlbmNlcyB9ID0gbm9kZVxuICAgIGNvbnN0IHsgbGVuZ3RoOiBvY2N1cmVuY2VzQ291bnQgfSA9IG9jY3VyZW5jZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9jY3VyZW5jZXNDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBvY2N1cmVuY2UgPSBvY2N1cmVuY2VzW2ldXG4gICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBvY2N1cmVuY2UuY29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgb2NjdXJlbmNlLmNvbW1lbnRzLCBjYXNlSW5kZW50LCBsaW5lRW5kKVxuICAgICAgfVxuICAgICAgaWYgKG9jY3VyZW5jZS50ZXN0KSB7XG4gICAgICAgIHN0YXRlLndyaXRlKGNhc2VJbmRlbnQgKyAnY2FzZSAnKVxuICAgICAgICB0aGlzW29jY3VyZW5jZS50ZXN0LnR5cGVdKG9jY3VyZW5jZS50ZXN0LCBzdGF0ZSlcbiAgICAgICAgc3RhdGUud3JpdGUoJzonICsgbGluZUVuZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLndyaXRlKGNhc2VJbmRlbnQgKyAnZGVmYXVsdDonICsgbGluZUVuZClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY29uc2VxdWVudCB9ID0gb2NjdXJlbmNlXG4gICAgICBjb25zdCB7IGxlbmd0aDogY29uc2VxdWVudENvdW50IH0gPSBjb25zZXF1ZW50XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnNlcXVlbnRDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlbWVudCA9IGNvbnNlcXVlbnRbaV1cbiAgICAgICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgc3RhdGVtZW50LmNvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgc3RhdGVtZW50LmNvbW1lbnRzLCBzdGF0ZW1lbnRJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUoc3RhdGVtZW50SW5kZW50KVxuICAgICAgICB0aGlzW3N0YXRlbWVudC50eXBlXShzdGF0ZW1lbnQsIHN0YXRlKVxuICAgICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS5pbmRlbnRMZXZlbCAtPSAyXG4gICAgc3RhdGUud3JpdGUoaW5kZW50ICsgJ30nKVxuICB9LFxuICBSZXR1cm5TdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgncmV0dXJuJylcbiAgICBpZiAobm9kZS5hcmd1bWVudCkge1xuICAgICAgc3RhdGUud3JpdGUoJyAnKVxuICAgICAgdGhpc1tub2RlLmFyZ3VtZW50LnR5cGVdKG5vZGUuYXJndW1lbnQsIHN0YXRlKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIFRocm93U3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3Rocm93ICcpXG4gICAgdGhpc1tub2RlLmFyZ3VtZW50LnR5cGVdKG5vZGUuYXJndW1lbnQsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgVHJ5U3RhdGVtZW50KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3RyeSAnKVxuICAgIHRoaXNbbm9kZS5ibG9jay50eXBlXShub2RlLmJsb2NrLCBzdGF0ZSlcbiAgICBpZiAobm9kZS5oYW5kbGVyKSB7XG4gICAgICBjb25zdCB7IGhhbmRsZXIgfSA9IG5vZGVcbiAgICAgIGlmIChoYW5kbGVyLnBhcmFtID09IG51bGwpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJyBjYXRjaCAnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJyBjYXRjaCAoJylcbiAgICAgICAgdGhpc1toYW5kbGVyLnBhcmFtLnR5cGVdKGhhbmRsZXIucGFyYW0sIHN0YXRlKVxuICAgICAgICBzdGF0ZS53cml0ZSgnKSAnKVxuICAgICAgfVxuICAgICAgdGhpc1toYW5kbGVyLmJvZHkudHlwZV0oaGFuZGxlci5ib2R5LCBzdGF0ZSlcbiAgICB9XG4gICAgaWYgKG5vZGUuZmluYWxpemVyKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnIGZpbmFsbHkgJylcbiAgICAgIHRoaXNbbm9kZS5maW5hbGl6ZXIudHlwZV0obm9kZS5maW5hbGl6ZXIsIHN0YXRlKVxuICAgIH1cbiAgfSxcbiAgV2hpbGVTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnd2hpbGUgKCcpXG4gICAgdGhpc1tub2RlLnRlc3QudHlwZV0obm9kZS50ZXN0LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnKSAnKVxuICAgIHRoaXNbbm9kZS5ib2R5LnR5cGVdKG5vZGUuYm9keSwgc3RhdGUpXG4gIH0sXG4gIERvV2hpbGVTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnZG8gJylcbiAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcgd2hpbGUgKCcpXG4gICAgdGhpc1tub2RlLnRlc3QudHlwZV0obm9kZS50ZXN0LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnKTsnKVxuICB9LFxuICBGb3JTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnZm9yICgnKVxuICAgIGlmIChub2RlLmluaXQgIT0gbnVsbCkge1xuICAgICAgY29uc3QgeyBpbml0IH0gPSBub2RlXG4gICAgICBpZiAoaW5pdC50eXBlWzBdID09PSAnVicpIHtcbiAgICAgICAgZm9ybWF0VmFyaWFibGVEZWNsYXJhdGlvbihzdGF0ZSwgaW5pdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbaW5pdC50eXBlXShpbml0LCBzdGF0ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUud3JpdGUoJzsgJylcbiAgICBpZiAobm9kZS50ZXN0KSB7XG4gICAgICB0aGlzW25vZGUudGVzdC50eXBlXShub2RlLnRlc3QsIHN0YXRlKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnOyAnKVxuICAgIGlmIChub2RlLnVwZGF0ZSkge1xuICAgICAgdGhpc1tub2RlLnVwZGF0ZS50eXBlXShub2RlLnVwZGF0ZSwgc3RhdGUpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCcpICcpXG4gICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgfSxcbiAgRm9ySW5TdGF0ZW1lbnQ6IChGb3JJblN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKGBmb3IgJHtub2RlLmF3YWl0ID8gJ2F3YWl0ICcgOiAnJ30oYClcbiAgICBjb25zdCB7IGxlZnQgfSA9IG5vZGVcbiAgICBpZiAobGVmdC50eXBlWzBdID09PSAnVicpIHtcbiAgICAgIGZvcm1hdFZhcmlhYmxlRGVjbGFyYXRpb24oc3RhdGUsIGxlZnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbGVmdC50eXBlXShsZWZ0LCBzdGF0ZSlcbiAgICB9XG4gICAgLy8gSWRlbnRpZnlpbmcgd2hldGhlciBub2RlLnR5cGUgaXMgYEZvckluU3RhdGVtZW50YCBvciBgRm9yT2ZTdGF0ZW1lbnRgXG4gICAgc3RhdGUud3JpdGUobm9kZS50eXBlWzNdID09PSAnSScgPyAnIGluICcgOiAnIG9mICcpXG4gICAgdGhpc1tub2RlLnJpZ2h0LnR5cGVdKG5vZGUucmlnaHQsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcpICcpXG4gICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgfSksXG4gIEZvck9mU3RhdGVtZW50OiBGb3JJblN0YXRlbWVudCxcbiAgRGVidWdnZXJTdGF0ZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnZGVidWdnZXI7Jywgbm9kZSlcbiAgfSxcbiAgRnVuY3Rpb25EZWNsYXJhdGlvbjogKEZ1bmN0aW9uRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZShcbiAgICAgIChub2RlLmFzeW5jID8gJ2FzeW5jICcgOiAnJykgK1xuICAgICAgICAobm9kZS5nZW5lcmF0b3IgPyAnZnVuY3Rpb24qICcgOiAnZnVuY3Rpb24gJykgK1xuICAgICAgICAobm9kZS5pZCA/IG5vZGUuaWQubmFtZSA6ICcnKSxcbiAgICAgIG5vZGUsXG4gICAgKVxuICAgIGZvcm1hdFNlcXVlbmNlKHN0YXRlLCBub2RlLnBhcmFtcylcbiAgICBzdGF0ZS53cml0ZSgnICcpXG4gICAgdGhpc1tub2RlLmJvZHkudHlwZV0obm9kZS5ib2R5LCBzdGF0ZSlcbiAgfSksXG4gIEZ1bmN0aW9uRXhwcmVzc2lvbjogRnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgVmFyaWFibGVEZWNsYXJhdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIGZvcm1hdFZhcmlhYmxlRGVjbGFyYXRpb24oc3RhdGUsIG5vZGUpXG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBWYXJpYWJsZURlY2xhcmF0b3Iobm9kZSwgc3RhdGUpIHtcbiAgICB0aGlzW25vZGUuaWQudHlwZV0obm9kZS5pZCwgc3RhdGUpXG4gICAgaWYgKG5vZGUuaW5pdCAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnID0gJylcbiAgICAgIHRoaXNbbm9kZS5pbml0LnR5cGVdKG5vZGUuaW5pdCwgc3RhdGUpXG4gICAgfVxuICB9LFxuICBDbGFzc0RlY2xhcmF0aW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2NsYXNzICcgKyAobm9kZS5pZCA/IGAke25vZGUuaWQubmFtZX0gYCA6ICcnKSwgbm9kZSlcbiAgICBpZiAobm9kZS5zdXBlckNsYXNzKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnZXh0ZW5kcyAnKVxuICAgICAgY29uc3QgeyBzdXBlckNsYXNzIH0gPSBub2RlXG4gICAgICBjb25zdCB7IHR5cGUgfSA9IHN1cGVyQ2xhc3NcbiAgICAgIGNvbnN0IHByZWNlZGVuY2UgPSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2VbdHlwZV1cbiAgICAgIGlmIChcbiAgICAgICAgKHR5cGVbMF0gIT09ICdDJyB8fCB0eXBlWzFdICE9PSAnbCcgfHwgdHlwZVs1XSAhPT0gJ0UnKSAmJlxuICAgICAgICAocHJlY2VkZW5jZSA9PT0gTkVFRFNfUEFSRU5USEVTRVMgfHxcbiAgICAgICAgICBwcmVjZWRlbmNlIDwgc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlLkNsYXNzRXhwcmVzc2lvbilcbiAgICAgICkge1xuICAgICAgICAvLyBOb3QgYSBDbGFzc0V4cHJlc3Npb24gdGhhdCBuZWVkcyBwYXJlbnRoZXNlc1xuICAgICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICAgIHRoaXNbbm9kZS5zdXBlckNsYXNzLnR5cGVdKHN1cGVyQ2xhc3MsIHN0YXRlKVxuICAgICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3N1cGVyQ2xhc3MudHlwZV0oc3VwZXJDbGFzcywgc3RhdGUpXG4gICAgICB9XG4gICAgICBzdGF0ZS53cml0ZSgnICcpXG4gICAgfVxuICAgIHRoaXMuQ2xhc3NCb2R5KG5vZGUuYm9keSwgc3RhdGUpXG4gIH0sXG4gIEltcG9ydERlY2xhcmF0aW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2ltcG9ydCAnKVxuICAgIGNvbnN0IHsgc3BlY2lmaWVycywgYXR0cmlidXRlcyB9ID0gbm9kZVxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBzcGVjaWZpZXJzXG4gICAgLy8gVE9ETzogT25jZSBiYWJpbGkgaXMgZml4ZWQsIHB1dCB0aGlzIGFmdGVyIGNvbmRpdGlvblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJpbGkvaXNzdWVzLzQzMFxuICAgIGxldCBpID0gMFxuICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgKSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BlY2lmaWVyID0gc3BlY2lmaWVyc1tpXVxuICAgICAgICBjb25zdCB0eXBlID0gc3BlY2lmaWVyLnR5cGVbNl1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdEJykge1xuICAgICAgICAgIC8vIEltcG9ydERlZmF1bHRTcGVjaWZpZXJcbiAgICAgICAgICBzdGF0ZS53cml0ZShzcGVjaWZpZXIubG9jYWwubmFtZSwgc3BlY2lmaWVyKVxuICAgICAgICAgIGkrK1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOJykge1xuICAgICAgICAgIC8vIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllclxuICAgICAgICAgIHN0YXRlLndyaXRlKCcqIGFzICcgKyBzcGVjaWZpZXIubG9jYWwubmFtZSwgc3BlY2lmaWVyKVxuICAgICAgICAgIGkrK1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEltcG9ydFNwZWNpZmllclxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCd7JylcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGNvbnN0IHNwZWNpZmllciA9IHNwZWNpZmllcnNbaV1cbiAgICAgICAgICBjb25zdCB7IG5hbWUgfSA9IHNwZWNpZmllci5pbXBvcnRlZFxuICAgICAgICAgIHN0YXRlLndyaXRlKG5hbWUsIHNwZWNpZmllcilcbiAgICAgICAgICBpZiAobmFtZSAhPT0gc3BlY2lmaWVyLmxvY2FsLm5hbWUpIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKCcgYXMgJyArIHNwZWNpZmllci5sb2NhbC5uYW1lKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS53cml0ZSgnfScpXG4gICAgICB9XG4gICAgICBzdGF0ZS53cml0ZSgnIGZyb20gJylcbiAgICB9XG4gICAgdGhpcy5MaXRlcmFsKG5vZGUuc291cmNlLCBzdGF0ZSlcblxuICAgIGlmIChhdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdGUud3JpdGUoJyB3aXRoIHsgJylcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLkltcG9ydEF0dHJpYnV0ZShhdHRyaWJ1dGVzW2ldLCBzdGF0ZSlcbiAgICAgICAgaWYgKGkgPCBhdHRyaWJ1dGVzLmxlbmd0aCAtIDEpIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICB9XG5cbiAgICAgIHN0YXRlLndyaXRlKCcgfScpXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCc7JylcbiAgfSxcbiAgSW1wb3J0QXR0cmlidXRlKG5vZGUsIHN0YXRlKSB7XG4gICAgdGhpcy5JZGVudGlmaWVyKG5vZGUua2V5LCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnOiAnKVxuICAgIHRoaXMuTGl0ZXJhbChub2RlLnZhbHVlLCBzdGF0ZSlcbiAgfSxcbiAgSW1wb3J0RXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdpbXBvcnQoJylcbiAgICB0aGlzW25vZGUuc291cmNlLnR5cGVdKG5vZGUuc291cmNlLCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnKScpXG4gIH0sXG4gIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCdleHBvcnQgZGVmYXVsdCAnKVxuICAgIHRoaXNbbm9kZS5kZWNsYXJhdGlvbi50eXBlXShub2RlLmRlY2xhcmF0aW9uLCBzdGF0ZSlcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2Vbbm9kZS5kZWNsYXJhdGlvbi50eXBlXSAhPSBudWxsICYmXG4gICAgICBub2RlLmRlY2xhcmF0aW9uLnR5cGVbMF0gIT09ICdGJ1xuICAgICkge1xuICAgICAgLy8gQWxsIGV4cHJlc3Npb24gbm9kZXMgZXhjZXB0IGBGdW5jdGlvbkV4cHJlc3Npb25gXG4gICAgICBzdGF0ZS53cml0ZSgnOycpXG4gICAgfVxuICB9LFxuICBFeHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ2V4cG9ydCAnKVxuICAgIGlmIChub2RlLmRlY2xhcmF0aW9uKSB7XG4gICAgICB0aGlzW25vZGUuZGVjbGFyYXRpb24udHlwZV0obm9kZS5kZWNsYXJhdGlvbiwgc3RhdGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLndyaXRlKCd7JylcbiAgICAgIGNvbnN0IHsgc3BlY2lmaWVycyB9ID0gbm9kZSxcbiAgICAgICAgeyBsZW5ndGggfSA9IHNwZWNpZmllcnNcbiAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyA7ICkge1xuICAgICAgICAgIGNvbnN0IHNwZWNpZmllciA9IHNwZWNpZmllcnNbaV1cbiAgICAgICAgICBjb25zdCB7IG5hbWUgfSA9IHNwZWNpZmllci5sb2NhbFxuICAgICAgICAgIHN0YXRlLndyaXRlKG5hbWUsIHNwZWNpZmllcilcbiAgICAgICAgICBpZiAobmFtZSAhPT0gc3BlY2lmaWVyLmV4cG9ydGVkLm5hbWUpIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKCcgYXMgJyArIHNwZWNpZmllci5leHBvcnRlZC5uYW1lKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoJ30nKVxuICAgICAgaWYgKG5vZGUuc291cmNlKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCcgZnJvbSAnKVxuICAgICAgICB0aGlzLkxpdGVyYWwobm9kZS5zb3VyY2UsIHN0YXRlKVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5hdHRyaWJ1dGVzICYmIG5vZGUuYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKCcgd2l0aCB7ICcpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5JbXBvcnRBdHRyaWJ1dGUobm9kZS5hdHRyaWJ1dGVzW2ldLCBzdGF0ZSlcbiAgICAgICAgICBpZiAoaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGggLSAxKSBzdGF0ZS53cml0ZSgnLCAnKVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUud3JpdGUoJyB9JylcbiAgICAgIH1cblxuICAgICAgc3RhdGUud3JpdGUoJzsnKVxuICAgIH1cbiAgfSxcbiAgRXhwb3J0QWxsRGVjbGFyYXRpb24obm9kZSwgc3RhdGUpIHtcbiAgICBpZiAobm9kZS5leHBvcnRlZCAhPSBudWxsKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnZXhwb3J0ICogYXMgJyArIG5vZGUuZXhwb3J0ZWQubmFtZSArICcgZnJvbSAnKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS53cml0ZSgnZXhwb3J0ICogZnJvbSAnKVxuICAgIH1cbiAgICB0aGlzLkxpdGVyYWwobm9kZS5zb3VyY2UsIHN0YXRlKVxuXG4gICAgaWYgKG5vZGUuYXR0cmlidXRlcyAmJiBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdGUud3JpdGUoJyB3aXRoIHsgJylcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuSW1wb3J0QXR0cmlidXRlKG5vZGUuYXR0cmlidXRlc1tpXSwgc3RhdGUpXG4gICAgICAgIGlmIChpIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCAtIDEpIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICB9XG5cbiAgICAgIHN0YXRlLndyaXRlKCcgfScpXG4gICAgfVxuXG4gICAgc3RhdGUud3JpdGUoJzsnKVxuICB9LFxuICBNZXRob2REZWZpbml0aW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnc3RhdGljICcpXG4gICAgfVxuICAgIGNvbnN0IGtpbmQgPSBub2RlLmtpbmRbMF1cbiAgICBpZiAoa2luZCA9PT0gJ2cnIHx8IGtpbmQgPT09ICdzJykge1xuICAgICAgLy8gR2V0dGVyIG9yIHNldHRlclxuICAgICAgc3RhdGUud3JpdGUobm9kZS5raW5kICsgJyAnKVxuICAgIH1cbiAgICBpZiAobm9kZS52YWx1ZS5hc3luYykge1xuICAgICAgc3RhdGUud3JpdGUoJ2FzeW5jICcpXG4gICAgfVxuICAgIGlmIChub2RlLnZhbHVlLmdlbmVyYXRvcikge1xuICAgICAgc3RhdGUud3JpdGUoJyonKVxuICAgIH1cbiAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgc3RhdGUud3JpdGUoJ1snKVxuICAgICAgdGhpc1tub2RlLmtleS50eXBlXShub2RlLmtleSwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnXScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbm9kZS5rZXkudHlwZV0obm9kZS5rZXksIHN0YXRlKVxuICAgIH1cbiAgICBmb3JtYXRTZXF1ZW5jZShzdGF0ZSwgbm9kZS52YWx1ZS5wYXJhbXMpXG4gICAgc3RhdGUud3JpdGUoJyAnKVxuICAgIHRoaXNbbm9kZS52YWx1ZS5ib2R5LnR5cGVdKG5vZGUudmFsdWUuYm9keSwgc3RhdGUpXG4gIH0sXG4gIENsYXNzRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIHRoaXMuQ2xhc3NEZWNsYXJhdGlvbihub2RlLCBzdGF0ZSlcbiAgfSxcbiAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZShub2RlLmFzeW5jID8gJ2FzeW5jICcgOiAnJywgbm9kZSlcbiAgICBjb25zdCB7IHBhcmFtcyB9ID0gbm9kZVxuICAgIGlmIChwYXJhbXMgIT0gbnVsbCkge1xuICAgICAgLy8gT21pdCBwYXJlbnRoZXNpcyBpZiBvbmx5IG9uZSBuYW1lZCBwYXJhbWV0ZXJcbiAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxICYmIHBhcmFtc1swXS50eXBlWzBdID09PSAnSScpIHtcbiAgICAgICAgLy8gSWYgcGFyYW1zWzBdLnR5cGVbMF0gc3RhcnRzIHdpdGggJ0knLCBpdCBjYW4ndCBiZSBgSW1wb3J0RGVjbGFyYXRpb25gIG5vciBgSWZTdGF0ZW1lbnRgIGFuZCB0aHVzIGlzIGBJZGVudGlmaWVyYFxuICAgICAgICBzdGF0ZS53cml0ZShwYXJhbXNbMF0ubmFtZSwgcGFyYW1zWzBdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9ybWF0U2VxdWVuY2Uoc3RhdGUsIG5vZGUucGFyYW1zKVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnID0+ICcpXG4gICAgaWYgKG5vZGUuYm9keS50eXBlWzBdID09PSAnTycpIHtcbiAgICAgIC8vIEJvZHkgaXMgYW4gb2JqZWN0IGV4cHJlc3Npb25cbiAgICAgIHN0YXRlLndyaXRlKCcoJylcbiAgICAgIHRoaXMuT2JqZWN0RXhwcmVzc2lvbihub2RlLmJvZHksIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW25vZGUuYm9keS50eXBlXShub2RlLmJvZHksIHN0YXRlKVxuICAgIH1cbiAgfSxcbiAgVGhpc0V4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgndGhpcycsIG5vZGUpXG4gIH0sXG4gIFN1cGVyKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ3N1cGVyJywgbm9kZSlcbiAgfSxcbiAgUmVzdEVsZW1lbnQ6IChSZXN0RWxlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdGF0ZSkge1xuICAgIHN0YXRlLndyaXRlKCcuLi4nKVxuICAgIHRoaXNbbm9kZS5hcmd1bWVudC50eXBlXShub2RlLmFyZ3VtZW50LCBzdGF0ZSlcbiAgfSksXG4gIFNwcmVhZEVsZW1lbnQ6IFJlc3RFbGVtZW50LFxuICBZaWVsZEV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZShub2RlLmRlbGVnYXRlID8gJ3lpZWxkKicgOiAneWllbGQnKVxuICAgIGlmIChub2RlLmFyZ3VtZW50KSB7XG4gICAgICBzdGF0ZS53cml0ZSgnICcpXG4gICAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gICAgfVxuICB9LFxuICBBd2FpdEV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnYXdhaXQgJywgbm9kZSlcbiAgICBmb3JtYXRFeHByZXNzaW9uKHN0YXRlLCBub2RlLmFyZ3VtZW50LCBub2RlKVxuICB9LFxuICBUZW1wbGF0ZUxpdGVyYWwobm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCB7IHF1YXNpcywgZXhwcmVzc2lvbnMgfSA9IG5vZGVcbiAgICBzdGF0ZS53cml0ZSgnYCcpXG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGV4cHJlc3Npb25zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25zW2ldXG4gICAgICBjb25zdCBxdWFzaSA9IHF1YXNpc1tpXVxuICAgICAgc3RhdGUud3JpdGUocXVhc2kudmFsdWUucmF3LCBxdWFzaSlcbiAgICAgIHN0YXRlLndyaXRlKCckeycpXG4gICAgICB0aGlzW2V4cHJlc3Npb24udHlwZV0oZXhwcmVzc2lvbiwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZSgnfScpXG4gICAgfVxuICAgIGNvbnN0IHF1YXNpID0gcXVhc2lzW3F1YXNpcy5sZW5ndGggLSAxXVxuICAgIHN0YXRlLndyaXRlKHF1YXNpLnZhbHVlLnJhdywgcXVhc2kpXG4gICAgc3RhdGUud3JpdGUoJ2AnKVxuICB9LFxuICBUZW1wbGF0ZUVsZW1lbnQobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZShub2RlLnZhbHVlLnJhdywgbm9kZSlcbiAgfSxcbiAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgZm9ybWF0RXhwcmVzc2lvbihzdGF0ZSwgbm9kZS50YWcsIG5vZGUpXG4gICAgdGhpc1tub2RlLnF1YXNpLnR5cGVdKG5vZGUucXVhc2ksIHN0YXRlKVxuICB9LFxuICBBcnJheUV4cHJlc3Npb246IChBcnJheUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgnWycpXG4gICAgaWYgKG5vZGUuZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgeyBlbGVtZW50cyB9ID0gbm9kZSxcbiAgICAgICAgeyBsZW5ndGggfSA9IGVsZW1lbnRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgOyApIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldXG4gICAgICAgIGlmIChlbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzW2VsZW1lbnQudHlwZV0oZWxlbWVudCwgc3RhdGUpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgIHN0YXRlLndyaXRlKCcsICcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUud3JpdGUoJywgJylcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnXScpXG4gIH0pLFxuICBBcnJheVBhdHRlcm46IEFycmF5RXhwcmVzc2lvbixcbiAgT2JqZWN0RXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IGluZGVudCA9IHN0YXRlLmluZGVudC5yZXBlYXQoc3RhdGUuaW5kZW50TGV2ZWwrKylcbiAgICBjb25zdCB7IGxpbmVFbmQsIHdyaXRlQ29tbWVudHMgfSA9IHN0YXRlXG4gICAgY29uc3QgcHJvcGVydHlJbmRlbnQgPSBpbmRlbnQgKyBzdGF0ZS5pbmRlbnRcbiAgICBzdGF0ZS53cml0ZSgneycpXG4gICAgaWYgKG5vZGUucHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgbm9kZS5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLmNvbW1lbnRzLCBwcm9wZXJ0eUluZGVudCwgbGluZUVuZClcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbW1hID0gJywnICsgbGluZUVuZFxuICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBub2RlLFxuICAgICAgICB7IGxlbmd0aCB9ID0gcHJvcGVydGllc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IDsgKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gcHJvcGVydGllc1tpXVxuICAgICAgICBpZiAod3JpdGVDb21tZW50cyAmJiBwcm9wZXJ0eS5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIHByb3BlcnR5LmNvbW1lbnRzLCBwcm9wZXJ0eUluZGVudCwgbGluZUVuZClcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS53cml0ZShwcm9wZXJ0eUluZGVudClcbiAgICAgICAgdGhpc1twcm9wZXJ0eS50eXBlXShwcm9wZXJ0eSwgc3RhdGUpXG4gICAgICAgIGlmICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICBzdGF0ZS53cml0ZShjb21tYSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgICAgaWYgKHdyaXRlQ29tbWVudHMgJiYgbm9kZS50cmFpbGluZ0NvbW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUudHJhaWxpbmdDb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICB9XG4gICAgICBzdGF0ZS53cml0ZShpbmRlbnQgKyAnfScpXG4gICAgfSBlbHNlIGlmICh3cml0ZUNvbW1lbnRzKSB7XG4gICAgICBpZiAobm9kZS5jb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgIHN0YXRlLndyaXRlKGxpbmVFbmQpXG4gICAgICAgIGZvcm1hdENvbW1lbnRzKHN0YXRlLCBub2RlLmNvbW1lbnRzLCBwcm9wZXJ0eUluZGVudCwgbGluZUVuZClcbiAgICAgICAgaWYgKG5vZGUudHJhaWxpbmdDb21tZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgZm9ybWF0Q29tbWVudHMoc3RhdGUsIG5vZGUudHJhaWxpbmdDb21tZW50cywgcHJvcGVydHlJbmRlbnQsIGxpbmVFbmQpXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JpdGUoaW5kZW50ICsgJ30nKVxuICAgICAgfSBlbHNlIGlmIChub2RlLnRyYWlsaW5nQ29tbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS53cml0ZShsaW5lRW5kKVxuICAgICAgICBmb3JtYXRDb21tZW50cyhzdGF0ZSwgbm9kZS50cmFpbGluZ0NvbW1lbnRzLCBwcm9wZXJ0eUluZGVudCwgbGluZUVuZClcbiAgICAgICAgc3RhdGUud3JpdGUoaW5kZW50ICsgJ30nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJ30nKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS53cml0ZSgnfScpXG4gICAgfVxuICAgIHN0YXRlLmluZGVudExldmVsLS1cbiAgfSxcbiAgUHJvcGVydHkobm9kZSwgc3RhdGUpIHtcbiAgICBpZiAobm9kZS5tZXRob2QgfHwgbm9kZS5raW5kWzBdICE9PSAnaScpIHtcbiAgICAgIC8vIEVpdGhlciBhIG1ldGhvZCBvciBvZiBraW5kIGBzZXRgIG9yIGBnZXRgIChub3QgYGluaXRgKVxuICAgICAgdGhpcy5NZXRob2REZWZpbml0aW9uKG5vZGUsIHN0YXRlKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW5vZGUuc2hvcnRoYW5kKSB7XG4gICAgICAgIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgICAgICAgc3RhdGUud3JpdGUoJ1snKVxuICAgICAgICAgIHRoaXNbbm9kZS5rZXkudHlwZV0obm9kZS5rZXksIHN0YXRlKVxuICAgICAgICAgIHN0YXRlLndyaXRlKCddJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzW25vZGUua2V5LnR5cGVdKG5vZGUua2V5LCBzdGF0ZSlcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS53cml0ZSgnOiAnKVxuICAgICAgfVxuICAgICAgdGhpc1tub2RlLnZhbHVlLnR5cGVdKG5vZGUudmFsdWUsIHN0YXRlKVxuICAgIH1cbiAgfSxcbiAgUHJvcGVydHlEZWZpbml0aW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnc3RhdGljICcpXG4gICAgfVxuICAgIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnWycpXG4gICAgfVxuICAgIHRoaXNbbm9kZS5rZXkudHlwZV0obm9kZS5rZXksIHN0YXRlKVxuICAgIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnXScpXG4gICAgfVxuICAgIGlmIChub2RlLnZhbHVlID09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLmtleS50eXBlWzBdICE9PSAnRicpIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJzsnKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCcgPSAnKVxuICAgIHRoaXNbbm9kZS52YWx1ZS50eXBlXShub2RlLnZhbHVlLCBzdGF0ZSlcbiAgICBzdGF0ZS53cml0ZSgnOycpXG4gIH0sXG4gIE9iamVjdFBhdHRlcm4obm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZSgneycpXG4gICAgaWYgKG5vZGUucHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB7IHByb3BlcnRpZXMgfSA9IG5vZGUsXG4gICAgICAgIHsgbGVuZ3RoIH0gPSBwcm9wZXJ0aWVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgOyApIHtcbiAgICAgICAgdGhpc1twcm9wZXJ0aWVzW2ldLnR5cGVdKHByb3BlcnRpZXNbaV0sIHN0YXRlKVxuICAgICAgICBpZiAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgc3RhdGUud3JpdGUoJywgJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLndyaXRlKCd9JylcbiAgfSxcbiAgU2VxdWVuY2VFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgZm9ybWF0U2VxdWVuY2Uoc3RhdGUsIG5vZGUuZXhwcmVzc2lvbnMpXG4gIH0sXG4gIFVuYXJ5RXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnByZWZpeCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBvcGVyYXRvcixcbiAgICAgICAgYXJndW1lbnQsXG4gICAgICAgIGFyZ3VtZW50OiB7IHR5cGUgfSxcbiAgICAgIH0gPSBub2RlXG4gICAgICBzdGF0ZS53cml0ZShvcGVyYXRvcilcbiAgICAgIGNvbnN0IG5lZWRzUGFyZW50aGVzZXMgPSBleHByZXNzaW9uTmVlZHNQYXJlbnRoZXNpcyhzdGF0ZSwgYXJndW1lbnQsIG5vZGUpXG4gICAgICBpZiAoXG4gICAgICAgICFuZWVkc1BhcmVudGhlc2VzICYmXG4gICAgICAgIChvcGVyYXRvci5sZW5ndGggPiAxIHx8XG4gICAgICAgICAgKHR5cGVbMF0gPT09ICdVJyAmJlxuICAgICAgICAgICAgKHR5cGVbMV0gPT09ICduJyB8fCB0eXBlWzFdID09PSAncCcpICYmXG4gICAgICAgICAgICBhcmd1bWVudC5wcmVmaXggJiZcbiAgICAgICAgICAgIGFyZ3VtZW50Lm9wZXJhdG9yWzBdID09PSBvcGVyYXRvciAmJlxuICAgICAgICAgICAgKG9wZXJhdG9yID09PSAnKycgfHwgb3BlcmF0b3IgPT09ICctJykpKVxuICAgICAgKSB7XG4gICAgICAgIC8vIExhcmdlIG9wZXJhdG9yIG9yIGFyZ3VtZW50IGlzIFVuYXJ5RXhwcmVzc2lvbiBvciBVcGRhdGVFeHByZXNzaW9uIG5vZGVcbiAgICAgICAgc3RhdGUud3JpdGUoJyAnKVxuICAgICAgfVxuICAgICAgaWYgKG5lZWRzUGFyZW50aGVzZXMpIHtcbiAgICAgICAgc3RhdGUud3JpdGUob3BlcmF0b3IubGVuZ3RoID4gMSA/ICcgKCcgOiAnKCcpXG4gICAgICAgIHRoaXNbdHlwZV0oYXJndW1lbnQsIHN0YXRlKVxuICAgICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3R5cGVdKGFyZ3VtZW50LCBzdGF0ZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRklYTUU6IFRoaXMgY2FzZSBuZXZlciBvY2N1cnNcbiAgICAgIHRoaXNbbm9kZS5hcmd1bWVudC50eXBlXShub2RlLmFyZ3VtZW50LCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKG5vZGUub3BlcmF0b3IpXG4gICAgfVxuICB9LFxuICBVcGRhdGVFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgLy8gQWx3YXlzIGFwcGxpZWQgdG8gaWRlbnRpZmllcnMgb3IgbWVtYmVycywgbm8gcGFyZW50aGVzaXMgY2hlY2sgbmVlZGVkXG4gICAgaWYgKG5vZGUucHJlZml4KSB7XG4gICAgICBzdGF0ZS53cml0ZShub2RlLm9wZXJhdG9yKVxuICAgICAgdGhpc1tub2RlLmFyZ3VtZW50LnR5cGVdKG5vZGUuYXJndW1lbnQsIHN0YXRlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW25vZGUuYXJndW1lbnQudHlwZV0obm9kZS5hcmd1bWVudCwgc3RhdGUpXG4gICAgICBzdGF0ZS53cml0ZShub2RlLm9wZXJhdG9yKVxuICAgIH1cbiAgfSxcbiAgQXNzaWdubWVudEV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICB0aGlzW25vZGUubGVmdC50eXBlXShub2RlLmxlZnQsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcgJyArIG5vZGUub3BlcmF0b3IgKyAnICcpXG4gICAgdGhpc1tub2RlLnJpZ2h0LnR5cGVdKG5vZGUucmlnaHQsIHN0YXRlKVxuICB9LFxuICBBc3NpZ25tZW50UGF0dGVybihub2RlLCBzdGF0ZSkge1xuICAgIHRoaXNbbm9kZS5sZWZ0LnR5cGVdKG5vZGUubGVmdCwgc3RhdGUpXG4gICAgc3RhdGUud3JpdGUoJyA9ICcpXG4gICAgdGhpc1tub2RlLnJpZ2h0LnR5cGVdKG5vZGUucmlnaHQsIHN0YXRlKVxuICB9LFxuICBCaW5hcnlFeHByZXNzaW9uOiAoQmluYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IGlzSW4gPSBub2RlLm9wZXJhdG9yID09PSAnaW4nXG4gICAgaWYgKGlzSW4pIHtcbiAgICAgIC8vIEF2b2lkcyBjb25mdXNpb24gaW4gYGZvcmAgbG9vcHMgaW5pdGlhbGl6ZXJzXG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgfVxuICAgIGZvcm1hdEV4cHJlc3Npb24oc3RhdGUsIG5vZGUubGVmdCwgbm9kZSwgZmFsc2UpXG4gICAgc3RhdGUud3JpdGUoJyAnICsgbm9kZS5vcGVyYXRvciArICcgJylcbiAgICBmb3JtYXRFeHByZXNzaW9uKHN0YXRlLCBub2RlLnJpZ2h0LCBub2RlLCB0cnVlKVxuICAgIGlmIChpc0luKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnKScpXG4gICAgfVxuICB9KSxcbiAgTG9naWNhbEV4cHJlc3Npb246IEJpbmFyeUV4cHJlc3Npb24sXG4gIENvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IHsgdGVzdCB9ID0gbm9kZVxuICAgIGNvbnN0IHByZWNlZGVuY2UgPSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2VbdGVzdC50eXBlXVxuICAgIGlmIChcbiAgICAgIHByZWNlZGVuY2UgPT09IE5FRURTX1BBUkVOVEhFU0VTIHx8XG4gICAgICBwcmVjZWRlbmNlIDw9IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZS5Db25kaXRpb25hbEV4cHJlc3Npb25cbiAgICApIHtcbiAgICAgIHN0YXRlLndyaXRlKCcoJylcbiAgICAgIHRoaXNbdGVzdC50eXBlXSh0ZXN0LCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1t0ZXN0LnR5cGVdKHRlc3QsIHN0YXRlKVxuICAgIH1cbiAgICBzdGF0ZS53cml0ZSgnID8gJylcbiAgICB0aGlzW25vZGUuY29uc2VxdWVudC50eXBlXShub2RlLmNvbnNlcXVlbnQsIHN0YXRlKVxuICAgIHN0YXRlLndyaXRlKCcgOiAnKVxuICAgIHRoaXNbbm9kZS5hbHRlcm5hdGUudHlwZV0obm9kZS5hbHRlcm5hdGUsIHN0YXRlKVxuICB9LFxuICBOZXdFeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoJ25ldyAnKVxuICAgIGNvbnN0IHByZWNlZGVuY2UgPSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2Vbbm9kZS5jYWxsZWUudHlwZV1cbiAgICBpZiAoXG4gICAgICBwcmVjZWRlbmNlID09PSBORUVEU19QQVJFTlRIRVNFUyB8fFxuICAgICAgcHJlY2VkZW5jZSA8IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZS5DYWxsRXhwcmVzc2lvbiB8fFxuICAgICAgaGFzQ2FsbEV4cHJlc3Npb24obm9kZS5jYWxsZWUpXG4gICAgKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzW25vZGUuY2FsbGVlLnR5cGVdKG5vZGUuY2FsbGVlLCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLmNhbGxlZS50eXBlXShub2RlLmNhbGxlZSwgc3RhdGUpXG4gICAgfVxuICAgIGZvcm1hdFNlcXVlbmNlKHN0YXRlLCBub2RlWydhcmd1bWVudHMnXSlcbiAgfSxcbiAgQ2FsbEV4cHJlc3Npb24obm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBwcmVjZWRlbmNlID0gc3RhdGUuZXhwcmVzc2lvbnNQcmVjZWRlbmNlW25vZGUuY2FsbGVlLnR5cGVdXG4gICAgaWYgKFxuICAgICAgcHJlY2VkZW5jZSA9PT0gTkVFRFNfUEFSRU5USEVTRVMgfHxcbiAgICAgIHByZWNlZGVuY2UgPCBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2UuQ2FsbEV4cHJlc3Npb25cbiAgICApIHtcbiAgICAgIHN0YXRlLndyaXRlKCcoJylcbiAgICAgIHRoaXNbbm9kZS5jYWxsZWUudHlwZV0obm9kZS5jYWxsZWUsIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJyknKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW25vZGUuY2FsbGVlLnR5cGVdKG5vZGUuY2FsbGVlLCBzdGF0ZSlcbiAgICB9XG4gICAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICAgIHN0YXRlLndyaXRlKCc/LicpXG4gICAgfVxuICAgIGZvcm1hdFNlcXVlbmNlKHN0YXRlLCBub2RlWydhcmd1bWVudHMnXSlcbiAgfSxcbiAgQ2hhaW5FeHByZXNzaW9uKG5vZGUsIHN0YXRlKSB7XG4gICAgdGhpc1tub2RlLmV4cHJlc3Npb24udHlwZV0obm9kZS5leHByZXNzaW9uLCBzdGF0ZSlcbiAgfSxcbiAgTWVtYmVyRXhwcmVzc2lvbihub2RlLCBzdGF0ZSkge1xuICAgIGNvbnN0IHByZWNlZGVuY2UgPSBzdGF0ZS5leHByZXNzaW9uc1ByZWNlZGVuY2Vbbm9kZS5vYmplY3QudHlwZV1cbiAgICBpZiAoXG4gICAgICBwcmVjZWRlbmNlID09PSBORUVEU19QQVJFTlRIRVNFUyB8fFxuICAgICAgcHJlY2VkZW5jZSA8IHN0YXRlLmV4cHJlc3Npb25zUHJlY2VkZW5jZS5NZW1iZXJFeHByZXNzaW9uXG4gICAgKSB7XG4gICAgICBzdGF0ZS53cml0ZSgnKCcpXG4gICAgICB0aGlzW25vZGUub2JqZWN0LnR5cGVdKG5vZGUub2JqZWN0LCBzdGF0ZSlcbiAgICAgIHN0YXRlLndyaXRlKCcpJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tub2RlLm9iamVjdC50eXBlXShub2RlLm9iamVjdCwgc3RhdGUpXG4gICAgfVxuICAgIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgICBpZiAobm9kZS5vcHRpb25hbCkge1xuICAgICAgICBzdGF0ZS53cml0ZSgnPy4nKVxuICAgICAgfVxuICAgICAgc3RhdGUud3JpdGUoJ1snKVxuICAgICAgdGhpc1tub2RlLnByb3BlcnR5LnR5cGVdKG5vZGUucHJvcGVydHksIHN0YXRlKVxuICAgICAgc3RhdGUud3JpdGUoJ10nKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobm9kZS5vcHRpb25hbCkge1xuICAgICAgICBzdGF0ZS53cml0ZSgnPy4nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUud3JpdGUoJy4nKVxuICAgICAgfVxuICAgICAgdGhpc1tub2RlLnByb3BlcnR5LnR5cGVdKG5vZGUucHJvcGVydHksIHN0YXRlKVxuICAgIH1cbiAgfSxcbiAgTWV0YVByb3BlcnR5KG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUobm9kZS5tZXRhLm5hbWUgKyAnLicgKyBub2RlLnByb3BlcnR5Lm5hbWUsIG5vZGUpXG4gIH0sXG4gIElkZW50aWZpZXIobm9kZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS53cml0ZShub2RlLm5hbWUsIG5vZGUpXG4gIH0sXG4gIFByaXZhdGVJZGVudGlmaWVyKG5vZGUsIHN0YXRlKSB7XG4gICAgc3RhdGUud3JpdGUoYCMke25vZGUubmFtZX1gLCBub2RlKVxuICB9LFxuICBMaXRlcmFsKG5vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUucmF3ICE9IG51bGwpIHtcbiAgICAgIC8vIE5vbi1zdGFuZGFyZCBwcm9wZXJ0eVxuICAgICAgc3RhdGUud3JpdGUobm9kZS5yYXcsIG5vZGUpXG4gICAgfSBlbHNlIGlmIChub2RlLnJlZ2V4ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuUmVnRXhwTGl0ZXJhbChub2RlLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKG5vZGUuYmlnaW50ICE9IG51bGwpIHtcbiAgICAgIHN0YXRlLndyaXRlKG5vZGUuYmlnaW50ICsgJ24nLCBub2RlKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS53cml0ZShzdHJpbmdpZnkobm9kZS52YWx1ZSksIG5vZGUpXG4gICAgfVxuICB9LFxuICBSZWdFeHBMaXRlcmFsKG5vZGUsIHN0YXRlKSB7XG4gICAgY29uc3QgeyByZWdleCB9ID0gbm9kZVxuICAgIHN0YXRlLndyaXRlKGAvJHtyZWdleC5wYXR0ZXJufS8ke3JlZ2V4LmZsYWdzfWAsIG5vZGUpXG4gIH0sXG59XG5cbmNvbnN0IEVNUFRZX09CSkVDVCA9IHt9XG5cbi8qXG5ERVBSRUNBVEVEOiBBbHRlcm5hdGUgZXhwb3J0IG9mIGBHRU5FUkFUT1JgLlxuKi9cbmV4cG9ydCBjb25zdCBiYXNlR2VuZXJhdG9yID0gR0VORVJBVE9SXG5cbmNsYXNzIFN0YXRlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHNldHVwID0gb3B0aW9ucyA9PSBudWxsID8gRU1QVFlfT0JKRUNUIDogb3B0aW9uc1xuICAgIHRoaXMub3V0cHV0ID0gJydcbiAgICAvLyBGdW5jdGlvbmFsIG9wdGlvbnNcbiAgICBpZiAoc2V0dXAub3V0cHV0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMub3V0cHV0ID0gc2V0dXAub3V0cHV0XG4gICAgICB0aGlzLndyaXRlID0gdGhpcy53cml0ZVRvU3RyZWFtXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3V0cHV0ID0gJydcbiAgICB9XG4gICAgdGhpcy5nZW5lcmF0b3IgPSBzZXR1cC5nZW5lcmF0b3IgIT0gbnVsbCA/IHNldHVwLmdlbmVyYXRvciA6IEdFTkVSQVRPUlxuICAgIHRoaXMuZXhwcmVzc2lvbnNQcmVjZWRlbmNlID1cbiAgICAgIHNldHVwLmV4cHJlc3Npb25zUHJlY2VkZW5jZSAhPSBudWxsXG4gICAgICAgID8gc2V0dXAuZXhwcmVzc2lvbnNQcmVjZWRlbmNlXG4gICAgICAgIDogRVhQUkVTU0lPTlNfUFJFQ0VERU5DRVxuICAgIC8vIEZvcm1hdGluZyBzZXR1cFxuICAgIHRoaXMuaW5kZW50ID0gc2V0dXAuaW5kZW50ICE9IG51bGwgPyBzZXR1cC5pbmRlbnQgOiAnICAnXG4gICAgdGhpcy5saW5lRW5kID0gc2V0dXAubGluZUVuZCAhPSBudWxsID8gc2V0dXAubGluZUVuZCA6ICdcXG4nXG4gICAgdGhpcy5pbmRlbnRMZXZlbCA9XG4gICAgICBzZXR1cC5zdGFydGluZ0luZGVudExldmVsICE9IG51bGwgPyBzZXR1cC5zdGFydGluZ0luZGVudExldmVsIDogMFxuICAgIHRoaXMud3JpdGVDb21tZW50cyA9IHNldHVwLmNvbW1lbnRzID8gc2V0dXAuY29tbWVudHMgOiBmYWxzZVxuICAgIC8vIFNvdXJjZSBtYXBcbiAgICBpZiAoc2V0dXAuc291cmNlTWFwICE9IG51bGwpIHtcbiAgICAgIHRoaXMud3JpdGUgPVxuICAgICAgICBzZXR1cC5vdXRwdXQgPT0gbnVsbCA/IHRoaXMud3JpdGVBbmRNYXAgOiB0aGlzLndyaXRlVG9TdHJlYW1BbmRNYXBcbiAgICAgIHRoaXMuc291cmNlTWFwID0gc2V0dXAuc291cmNlTWFwXG4gICAgICB0aGlzLmxpbmUgPSAxXG4gICAgICB0aGlzLmNvbHVtbiA9IDBcbiAgICAgIHRoaXMubGluZUVuZFNpemUgPSB0aGlzLmxpbmVFbmQuc3BsaXQoJ1xcbicpLmxlbmd0aCAtIDFcbiAgICAgIHRoaXMubWFwcGluZyA9IHtcbiAgICAgICAgb3JpZ2luYWw6IG51bGwsXG4gICAgICAgIC8vIFVzZXMgdGhlIGVudGlyZSBzdGF0ZSB0byBhdm9pZCBnZW5lcmF0aW5nIGVwaGVtZXJhbCBvYmplY3RzXG4gICAgICAgIGdlbmVyYXRlZDogdGhpcyxcbiAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICBzb3VyY2U6IHNldHVwLnNvdXJjZU1hcC5maWxlIHx8IHNldHVwLnNvdXJjZU1hcC5fZmlsZSxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3cml0ZShjb2RlKSB7XG4gICAgdGhpcy5vdXRwdXQgKz0gY29kZVxuICB9XG5cbiAgd3JpdGVUb1N0cmVhbShjb2RlKSB7XG4gICAgdGhpcy5vdXRwdXQud3JpdGUoY29kZSlcbiAgfVxuXG4gIHdyaXRlQW5kTWFwKGNvZGUsIG5vZGUpIHtcbiAgICB0aGlzLm91dHB1dCArPSBjb2RlXG4gICAgdGhpcy5tYXAoY29kZSwgbm9kZSlcbiAgfVxuXG4gIHdyaXRlVG9TdHJlYW1BbmRNYXAoY29kZSwgbm9kZSkge1xuICAgIHRoaXMub3V0cHV0LndyaXRlKGNvZGUpXG4gICAgdGhpcy5tYXAoY29kZSwgbm9kZSlcbiAgfVxuXG4gIG1hcChjb2RlLCBub2RlKSB7XG4gICAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgY29uc3QgeyB0eXBlIH0gPSBub2RlXG4gICAgICBpZiAodHlwZVswXSA9PT0gJ0wnICYmIHR5cGVbMl0gPT09ICduJykge1xuICAgICAgICAvLyBMaW5lQ29tbWVudFxuICAgICAgICB0aGlzLmNvbHVtbiA9IDBcbiAgICAgICAgdGhpcy5saW5lKytcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAobm9kZS5sb2MgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IG1hcHBpbmcgfSA9IHRoaXNcbiAgICAgICAgbWFwcGluZy5vcmlnaW5hbCA9IG5vZGUubG9jLnN0YXJ0XG4gICAgICAgIG1hcHBpbmcubmFtZSA9IG5vZGUubmFtZVxuICAgICAgICB0aGlzLnNvdXJjZU1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpXG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgICh0eXBlWzBdID09PSAnVCcgJiYgdHlwZVs4XSA9PT0gJ0UnKSB8fFxuICAgICAgICAodHlwZVswXSA9PT0gJ0wnICYmIHR5cGVbMV0gPT09ICdpJyAmJiB0eXBlb2Ygbm9kZS52YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICApIHtcbiAgICAgICAgLy8gVGVtcGxhdGVFbGVtZW50IG9yIExpdGVyYWwgc3RyaW5nIG5vZGVcbiAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IGNvZGVcbiAgICAgICAgbGV0IHsgY29sdW1uLCBsaW5lIH0gPSB0aGlzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoY29kZVtpXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGNvbHVtbiA9IDBcbiAgICAgICAgICAgIGxpbmUrK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW4rK1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtblxuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gY29kZVxuICAgIGNvbnN0IHsgbGluZUVuZCB9ID0gdGhpc1xuICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMubGluZUVuZFNpemUgPiAwICYmXG4gICAgICAgIChsaW5lRW5kLmxlbmd0aCA9PT0gMVxuICAgICAgICAgID8gY29kZVtsZW5ndGggLSAxXSA9PT0gbGluZUVuZFxuICAgICAgICAgIDogY29kZS5lbmRzV2l0aChsaW5lRW5kKSlcbiAgICAgICkge1xuICAgICAgICB0aGlzLmxpbmUgKz0gdGhpcy5saW5lRW5kU2l6ZVxuICAgICAgICB0aGlzLmNvbHVtbiA9IDBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29sdW1uICs9IGxlbmd0aFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZShub2RlLCBvcHRpb25zKSB7XG4gIC8qXG4gIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByZW5kZXJlZCBjb2RlIG9mIHRoZSBwcm92aWRlZCBBU1QgYG5vZGVgLlxuICBUaGUgYG9wdGlvbnNgIGFyZTpcblxuICAtIGBpbmRlbnRgOiBzdHJpbmcgdG8gdXNlIGZvciBpbmRlbnRhdGlvbiAoZGVmYXVsdHMgdG8gYOKQo+KQo2ApXG4gIC0gYGxpbmVFbmRgOiBzdHJpbmcgdG8gdXNlIGZvciBsaW5lIGVuZGluZ3MgKGRlZmF1bHRzIHRvIGBcXG5gKVxuICAtIGBzdGFydGluZ0luZGVudExldmVsYDogaW5kZW50IGxldmVsIHRvIHN0YXJ0IGZyb20gKGRlZmF1bHRzIHRvIGAwYClcbiAgLSBgY29tbWVudHNgOiBnZW5lcmF0ZSBjb21tZW50cyBpZiBgdHJ1ZWAgKGRlZmF1bHRzIHRvIGBmYWxzZWApXG4gIC0gYG91dHB1dGA6IG91dHB1dCBzdHJlYW0gdG8gd3JpdGUgdGhlIHJlbmRlcmVkIGNvZGUgdG8gKGRlZmF1bHRzIHRvIGBudWxsYClcbiAgLSBgZ2VuZXJhdG9yYDogY3VzdG9tIGNvZGUgZ2VuZXJhdG9yIChkZWZhdWx0cyB0byBgR0VORVJBVE9SYClcbiAgLSBgZXhwcmVzc2lvbnNQcmVjZWRlbmNlYDogY3VzdG9tIG1hcCBvZiBub2RlIHR5cGVzIGFuZCB0aGVpciBwcmVjZWRlbmNlIGxldmVsIChkZWZhdWx0cyB0byBgRVhQUkVTU0lPTlNfUFJFQ0VERU5DRWApXG4gICovXG4gIGNvbnN0IHN0YXRlID0gbmV3IFN0YXRlKG9wdGlvbnMpXG4gIC8vIFRyYXZlbCB0aHJvdWdoIHRoZSBBU1Qgbm9kZSBhbmQgZ2VuZXJhdGUgdGhlIGNvZGVcbiAgc3RhdGUuZ2VuZXJhdG9yW25vZGUudHlwZV0obm9kZSwgc3RhdGUpXG4gIHJldHVybiBzdGF0ZS5vdXRwdXRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/astring/dist/astring.mjs\n");

/***/ })

};
;