"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/compressorjs";
exports.ids = ["vendor-chunks/compressorjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/compressorjs/dist/compressor.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/compressorjs/dist/compressor.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Compressor)\n/* harmony export */ });\n/*!\n * Compressor.js v1.2.1\n * https://fengyuanchen.github.io/compressorjs\n *\n * Copyright 2018-present Chen Fengyuan\n * Released under the MIT license\n *\n * Date: 2023-02-28T14:09:41.732Z\n */\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar canvasToBlob = {exports: {}};\n\n/*\n * JavaScript Canvas to Blob\n * https://github.com/blueimp/JavaScript-Canvas-to-Blob\n *\n * Copyright 2012, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on stackoverflow user Stoive's code snippet:\n * http://stackoverflow.com/q/4998908\n */\n(function (module) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  (function (window) {\n\n    var CanvasPrototype = window.HTMLCanvasElement && window.HTMLCanvasElement.prototype;\n    var hasBlobConstructor = window.Blob && function () {\n      try {\n        return Boolean(new Blob());\n      } catch (e) {\n        return false;\n      }\n    }();\n    var hasArrayBufferViewSupport = hasBlobConstructor && window.Uint8Array && function () {\n      try {\n        return new Blob([new Uint8Array(100)]).size === 100;\n      } catch (e) {\n        return false;\n      }\n    }();\n    var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n    var dataURIPattern = /^data:((.*?)(;charset=.*?)?)(;base64)?,/;\n    var dataURLtoBlob = (hasBlobConstructor || BlobBuilder) && window.atob && window.ArrayBuffer && window.Uint8Array && function (dataURI) {\n      var matches, mediaType, isBase64, dataString, byteString, arrayBuffer, intArray, i, bb;\n      // Parse the dataURI components as per RFC 2397\n      matches = dataURI.match(dataURIPattern);\n      if (!matches) {\n        throw new Error('invalid data URI');\n      }\n      // Default to text/plain;charset=US-ASCII\n      mediaType = matches[2] ? matches[1] : 'text/plain' + (matches[3] || ';charset=US-ASCII');\n      isBase64 = !!matches[4];\n      dataString = dataURI.slice(matches[0].length);\n      if (isBase64) {\n        // Convert base64 to raw binary data held in a string:\n        byteString = atob(dataString);\n      } else {\n        // Convert base64/URLEncoded data component to raw binary:\n        byteString = decodeURIComponent(dataString);\n      }\n      // Write the bytes of the string to an ArrayBuffer:\n      arrayBuffer = new ArrayBuffer(byteString.length);\n      intArray = new Uint8Array(arrayBuffer);\n      for (i = 0; i < byteString.length; i += 1) {\n        intArray[i] = byteString.charCodeAt(i);\n      }\n      // Write the ArrayBuffer (or ArrayBufferView) to a blob:\n      if (hasBlobConstructor) {\n        return new Blob([hasArrayBufferViewSupport ? intArray : arrayBuffer], {\n          type: mediaType\n        });\n      }\n      bb = new BlobBuilder();\n      bb.append(arrayBuffer);\n      return bb.getBlob(mediaType);\n    };\n    if (window.HTMLCanvasElement && !CanvasPrototype.toBlob) {\n      if (CanvasPrototype.mozGetAsFile) {\n        CanvasPrototype.toBlob = function (callback, type, quality) {\n          var self = this;\n          setTimeout(function () {\n            if (quality && CanvasPrototype.toDataURL && dataURLtoBlob) {\n              callback(dataURLtoBlob(self.toDataURL(type, quality)));\n            } else {\n              callback(self.mozGetAsFile('blob', type));\n            }\n          });\n        };\n      } else if (CanvasPrototype.toDataURL && dataURLtoBlob) {\n        if (CanvasPrototype.msToBlob) {\n          CanvasPrototype.toBlob = function (callback, type, quality) {\n            var self = this;\n            setTimeout(function () {\n              if ((type && type !== 'image/png' || quality) && CanvasPrototype.toDataURL && dataURLtoBlob) {\n                callback(dataURLtoBlob(self.toDataURL(type, quality)));\n              } else {\n                callback(self.msToBlob(type));\n              }\n            });\n          };\n        } else {\n          CanvasPrototype.toBlob = function (callback, type, quality) {\n            var self = this;\n            setTimeout(function () {\n              callback(dataURLtoBlob(self.toDataURL(type, quality)));\n            });\n          };\n        }\n      }\n    }\n    if (module.exports) {\n      module.exports = dataURLtoBlob;\n    } else {\n      window.dataURLtoBlob = dataURLtoBlob;\n    }\n  })(window);\n})(canvasToBlob);\nvar toBlob = canvasToBlob.exports;\n\nvar isBlob = function isBlob(value) {\n  if (typeof Blob === 'undefined') {\n    return false;\n  }\n  return value instanceof Blob || Object.prototype.toString.call(value) === '[object Blob]';\n};\n\nvar DEFAULTS = {\n  /**\n   * Indicates if output the original image instead of the compressed one\n   * when the size of the compressed image is greater than the original one's\n   * @type {boolean}\n   */\n  strict: true,\n  /**\n   * Indicates if read the image's Exif Orientation information,\n   * and then rotate or flip the image automatically.\n   * @type {boolean}\n   */\n  checkOrientation: true,\n  /**\n   * Indicates if retain the image's Exif information after compressed.\n   * @type {boolean}\n  */\n  retainExif: false,\n  /**\n   * The max width of the output image.\n   * @type {number}\n   */\n  maxWidth: Infinity,\n  /**\n   * The max height of the output image.\n   * @type {number}\n   */\n  maxHeight: Infinity,\n  /**\n   * The min width of the output image.\n   * @type {number}\n   */\n  minWidth: 0,\n  /**\n   * The min height of the output image.\n   * @type {number}\n   */\n  minHeight: 0,\n  /**\n   * The width of the output image.\n   * If not specified, the natural width of the source image will be used.\n   * @type {number}\n   */\n  width: undefined,\n  /**\n   * The height of the output image.\n   * If not specified, the natural height of the source image will be used.\n   * @type {number}\n   */\n  height: undefined,\n  /**\n   * Sets how the size of the image should be resized to the container\n   * specified by the `width` and `height` options.\n   * @type {string}\n   */\n  resize: 'none',\n  /**\n   * The quality of the output image.\n   * It must be a number between `0` and `1`,\n   * and only available for `image/jpeg` and `image/webp` images.\n   * Check out {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob canvas.toBlob}.\n   * @type {number}\n   */\n  quality: 0.8,\n  /**\n   * The mime type of the output image.\n   * By default, the original mime type of the source image file will be used.\n   * @type {string}\n   */\n  mimeType: 'auto',\n  /**\n   * Files whose file type is included in this list,\n   * and whose file size exceeds the `convertSize` value will be converted to JPEGs.\n   * @type {string｜Array}\n   */\n  convertTypes: ['image/png'],\n  /**\n   * PNG files over this size (5 MB by default) will be converted to JPEGs.\n   * To disable this, just set the value to `Infinity`.\n   * @type {number}\n   */\n  convertSize: 5000000,\n  /**\n   * The hook function to execute before draw the image into the canvas for compression.\n   * @type {Function}\n   * @param {CanvasRenderingContext2D} context - The 2d rendering context of the canvas.\n   * @param {HTMLCanvasElement} canvas - The canvas for compression.\n   * @example\n   * function (context, canvas) {\n   *   context.fillStyle = '#fff';\n   * }\n   */\n  beforeDraw: null,\n  /**\n   * The hook function to execute after drew the image into the canvas for compression.\n   * @type {Function}\n   * @param {CanvasRenderingContext2D} context - The 2d rendering context of the canvas.\n   * @param {HTMLCanvasElement} canvas - The canvas for compression.\n   * @example\n   * function (context, canvas) {\n   *   context.filter = 'grayscale(100%)';\n   * }\n   */\n  drew: null,\n  /**\n   * The hook function to execute when success to compress the image.\n   * @type {Function}\n   * @param {File} file - The compressed image File object.\n   * @example\n   * function (file) {\n   *   console.log(file);\n   * }\n   */\n  success: null,\n  /**\n   * The hook function to execute when fail to compress the image.\n   * @type {Function}\n   * @param {Error} err - An Error object.\n   * @example\n   * function (err) {\n   *   console.log(err.message);\n   * }\n   */\n  error: null\n};\n\nvar IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';\nvar WINDOW = IS_BROWSER ? window : {};\n\n/**\n * Check if the given value is a positive number.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given value is a positive number, else `false`.\n */\nvar isPositiveNumber = function isPositiveNumber(value) {\n  return value > 0 && value < Infinity;\n};\nvar slice = Array.prototype.slice;\n\n/**\n * Convert array-like or iterable object to an array.\n * @param {*} value - The value to convert.\n * @returns {Array} Returns a new array.\n */\nfunction toArray(value) {\n  return Array.from ? Array.from(value) : slice.call(value);\n}\nvar REGEXP_IMAGE_TYPE = /^image\\/.+$/;\n\n/**\n * Check if the given value is a mime type of image.\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if the given is a mime type of image, else `false`.\n */\nfunction isImageType(value) {\n  return REGEXP_IMAGE_TYPE.test(value);\n}\n\n/**\n * Convert image type to extension.\n * @param {string} value - The image type to convert.\n * @returns {boolean} Returns the image extension.\n */\nfunction imageTypeToExtension(value) {\n  var extension = isImageType(value) ? value.substr(6) : '';\n  if (extension === 'jpeg') {\n    extension = 'jpg';\n  }\n  return \".\".concat(extension);\n}\nvar fromCharCode = String.fromCharCode;\n\n/**\n * Get string from char code in data view.\n * @param {DataView} dataView - The data view for read.\n * @param {number} start - The start index.\n * @param {number} length - The read length.\n * @returns {string} The read result.\n */\nfunction getStringFromCharCode(dataView, start, length) {\n  var str = '';\n  var i;\n  length += start;\n  for (i = start; i < length; i += 1) {\n    str += fromCharCode(dataView.getUint8(i));\n  }\n  return str;\n}\nvar btoa = WINDOW.btoa;\n\n/**\n * Transform array buffer to Data URL.\n * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.\n * @param {string} mimeType - The mime type of the Data URL.\n * @returns {string} The result Data URL.\n */\nfunction arrayBufferToDataURL(arrayBuffer, mimeType) {\n  var chunks = [];\n  var chunkSize = 8192;\n  var uint8 = new Uint8Array(arrayBuffer);\n  while (uint8.length > 0) {\n    // XXX: Babel's `toConsumableArray` helper will throw error in IE or Safari 9\n    // eslint-disable-next-line prefer-spread\n    chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));\n    uint8 = uint8.subarray(chunkSize);\n  }\n  return \"data:\".concat(mimeType, \";base64,\").concat(btoa(chunks.join('')));\n}\n\n/**\n * Get orientation value from given array buffer.\n * @param {ArrayBuffer} arrayBuffer - The array buffer to read.\n * @returns {number} The read orientation value.\n */\nfunction resetAndGetOrientation(arrayBuffer) {\n  var dataView = new DataView(arrayBuffer);\n  var orientation;\n\n  // Ignores range error when the image does not have correct Exif information\n  try {\n    var littleEndian;\n    var app1Start;\n    var ifdStart;\n\n    // Only handle JPEG image (start by 0xFFD8)\n    if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {\n      var length = dataView.byteLength;\n      var offset = 2;\n      while (offset + 1 < length) {\n        if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {\n          app1Start = offset;\n          break;\n        }\n        offset += 1;\n      }\n    }\n    if (app1Start) {\n      var exifIDCode = app1Start + 4;\n      var tiffOffset = app1Start + 10;\n      if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {\n        var endianness = dataView.getUint16(tiffOffset);\n        littleEndian = endianness === 0x4949;\n        if (littleEndian || endianness === 0x4D4D /* bigEndian */) {\n          if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {\n            var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\n            if (firstIFDOffset >= 0x00000008) {\n              ifdStart = tiffOffset + firstIFDOffset;\n            }\n          }\n        }\n      }\n    }\n    if (ifdStart) {\n      var _length = dataView.getUint16(ifdStart, littleEndian);\n      var _offset;\n      var i;\n      for (i = 0; i < _length; i += 1) {\n        _offset = ifdStart + i * 12 + 2;\n        if (dataView.getUint16(_offset, littleEndian) === 0x0112 /* Orientation */) {\n          // 8 is the offset of the current tag's value\n          _offset += 8;\n\n          // Get the original orientation value\n          orientation = dataView.getUint16(_offset, littleEndian);\n\n          // Override the orientation with its default value\n          dataView.setUint16(_offset, 1, littleEndian);\n          break;\n        }\n      }\n    }\n  } catch (e) {\n    orientation = 1;\n  }\n  return orientation;\n}\n\n/**\n * Parse Exif Orientation value.\n * @param {number} orientation - The orientation to parse.\n * @returns {Object} The parsed result.\n */\nfunction parseOrientation(orientation) {\n  var rotate = 0;\n  var scaleX = 1;\n  var scaleY = 1;\n  switch (orientation) {\n    // Flip horizontal\n    case 2:\n      scaleX = -1;\n      break;\n\n    // Rotate left 180°\n    case 3:\n      rotate = -180;\n      break;\n\n    // Flip vertical\n    case 4:\n      scaleY = -1;\n      break;\n\n    // Flip vertical and rotate right 90°\n    case 5:\n      rotate = 90;\n      scaleY = -1;\n      break;\n\n    // Rotate right 90°\n    case 6:\n      rotate = 90;\n      break;\n\n    // Flip horizontal and rotate right 90°\n    case 7:\n      rotate = 90;\n      scaleX = -1;\n      break;\n\n    // Rotate left 90°\n    case 8:\n      rotate = -90;\n      break;\n  }\n  return {\n    rotate: rotate,\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n}\nvar REGEXP_DECIMALS = /\\.\\d*(?:0|9){12}\\d*$/;\n\n/**\n * Normalize decimal number.\n * Check out {@link https://0.30000000000000004.com/}\n * @param {number} value - The value to normalize.\n * @param {number} [times=100000000000] - The times for normalizing.\n * @returns {number} Returns the normalized number.\n */\nfunction normalizeDecimalNumber(value) {\n  var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;\n  return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;\n}\n\n/**\n * Get the max sizes in a rectangle under the given aspect ratio.\n * @param {Object} data - The original sizes.\n * @param {string} [type='contain'] - The adjust type.\n * @returns {Object} The result sizes.\n */\nfunction getAdjustedSizes(_ref) {\n  var aspectRatio = _ref.aspectRatio,\n    height = _ref.height,\n    width = _ref.width;\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'none';\n  var isValidWidth = isPositiveNumber(width);\n  var isValidHeight = isPositiveNumber(height);\n  if (isValidWidth && isValidHeight) {\n    var adjustedWidth = height * aspectRatio;\n    if ((type === 'contain' || type === 'none') && adjustedWidth > width || type === 'cover' && adjustedWidth < width) {\n      height = width / aspectRatio;\n    } else {\n      width = height * aspectRatio;\n    }\n  } else if (isValidWidth) {\n    height = width / aspectRatio;\n  } else if (isValidHeight) {\n    width = height * aspectRatio;\n  }\n  return {\n    width: width,\n    height: height\n  };\n}\n\n/**\n * Get Exif information from the given array buffer.\n * @param {ArrayBuffer} arrayBuffer - The array buffer to read.\n * @returns {Array} The read Exif information.\n */\nfunction getExif(arrayBuffer) {\n  var array = toArray(new Uint8Array(arrayBuffer));\n  var length = array.length;\n  var segments = [];\n  var start = 0;\n  while (start + 3 < length) {\n    var value = array[start];\n    var next = array[start + 1];\n\n    // SOS (Start of Scan)\n    if (value === 0xFF && next === 0xDA) {\n      break;\n    }\n\n    // SOI (Start of Image)\n    if (value === 0xFF && next === 0xD8) {\n      start += 2;\n    } else {\n      var offset = array[start + 2] * 256 + array[start + 3];\n      var end = start + offset + 2;\n      var segment = array.slice(start, end);\n      segments.push(segment);\n      start = end;\n    }\n  }\n  return segments.reduce(function (exifArray, current) {\n    if (current[0] === 0xFF && current[1] === 0xE1) {\n      return exifArray.concat(current);\n    }\n    return exifArray;\n  }, []);\n}\n\n/**\n * Insert Exif information into the given array buffer.\n * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.\n * @param {Array} exifArray - The Exif information to insert.\n * @returns {ArrayBuffer} The transformed array buffer.\n */\nfunction insertExif(arrayBuffer, exifArray) {\n  var array = toArray(new Uint8Array(arrayBuffer));\n  if (array[2] !== 0xFF || array[3] !== 0xE0) {\n    return arrayBuffer;\n  }\n  var app0Length = array[4] * 256 + array[5];\n  var newArrayBuffer = [0xFF, 0xD8].concat(exifArray, array.slice(4 + app0Length));\n  return new Uint8Array(newArrayBuffer);\n}\n\nvar ArrayBuffer$1 = WINDOW.ArrayBuffer,\n  FileReader = WINDOW.FileReader;\nvar URL = WINDOW.URL || WINDOW.webkitURL;\nvar REGEXP_EXTENSION = /\\.\\w+$/;\nvar AnotherCompressor = WINDOW.Compressor;\n\n/**\n * Creates a new image compressor.\n * @class\n */\nvar Compressor = /*#__PURE__*/function () {\n  /**\n   * The constructor of Compressor.\n   * @param {File|Blob} file - The target image file for compressing.\n   * @param {Object} [options] - The options for compressing.\n   */\n  function Compressor(file, options) {\n    _classCallCheck(this, Compressor);\n    this.file = file;\n    this.exif = [];\n    this.image = new Image();\n    this.options = _objectSpread2(_objectSpread2({}, DEFAULTS), options);\n    this.aborted = false;\n    this.result = null;\n    this.init();\n  }\n  _createClass(Compressor, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n      var file = this.file,\n        options = this.options;\n      if (!isBlob(file)) {\n        this.fail(new Error('The first argument must be a File or Blob object.'));\n        return;\n      }\n      var mimeType = file.type;\n      if (!isImageType(mimeType)) {\n        this.fail(new Error('The first argument must be an image File or Blob object.'));\n        return;\n      }\n      if (!URL || !FileReader) {\n        this.fail(new Error('The current browser does not support image compression.'));\n        return;\n      }\n      if (!ArrayBuffer$1) {\n        options.checkOrientation = false;\n        options.retainExif = false;\n      }\n      var isJPEGImage = mimeType === 'image/jpeg';\n      var checkOrientation = isJPEGImage && options.checkOrientation;\n      var retainExif = isJPEGImage && options.retainExif;\n      if (URL && !checkOrientation && !retainExif) {\n        this.load({\n          url: URL.createObjectURL(file)\n        });\n      } else {\n        var reader = new FileReader();\n        this.reader = reader;\n        reader.onload = function (_ref) {\n          var target = _ref.target;\n          var result = target.result;\n          var data = {};\n          var orientation = 1;\n          if (checkOrientation) {\n            // Reset the orientation value to its default value 1\n            // as some iOS browsers will render image with its orientation\n            orientation = resetAndGetOrientation(result);\n            if (orientation > 1) {\n              _extends(data, parseOrientation(orientation));\n            }\n          }\n          if (retainExif) {\n            _this.exif = getExif(result);\n          }\n          if (checkOrientation || retainExif) {\n            if (!URL\n\n            // Generate a new URL with the default orientation value 1.\n            || orientation > 1) {\n              data.url = arrayBufferToDataURL(result, mimeType);\n            } else {\n              data.url = URL.createObjectURL(file);\n            }\n          } else {\n            data.url = result;\n          }\n          _this.load(data);\n        };\n        reader.onabort = function () {\n          _this.fail(new Error('Aborted to read the image with FileReader.'));\n        };\n        reader.onerror = function () {\n          _this.fail(new Error('Failed to read the image with FileReader.'));\n        };\n        reader.onloadend = function () {\n          _this.reader = null;\n        };\n        if (checkOrientation || retainExif) {\n          reader.readAsArrayBuffer(file);\n        } else {\n          reader.readAsDataURL(file);\n        }\n      }\n    }\n  }, {\n    key: \"load\",\n    value: function load(data) {\n      var _this2 = this;\n      var file = this.file,\n        image = this.image;\n      image.onload = function () {\n        _this2.draw(_objectSpread2(_objectSpread2({}, data), {}, {\n          naturalWidth: image.naturalWidth,\n          naturalHeight: image.naturalHeight\n        }));\n      };\n      image.onabort = function () {\n        _this2.fail(new Error('Aborted to load the image.'));\n      };\n      image.onerror = function () {\n        _this2.fail(new Error('Failed to load the image.'));\n      };\n\n      // Match all browsers that use WebKit as the layout engine in iOS devices,\n      // such as Safari for iOS, Chrome for iOS, and in-app browsers.\n      if (WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent)) {\n        // Fix the `The operation is insecure` error (#57)\n        image.crossOrigin = 'anonymous';\n      }\n      image.alt = file.name;\n      image.src = data.url;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref2) {\n      var _this3 = this;\n      var naturalWidth = _ref2.naturalWidth,\n        naturalHeight = _ref2.naturalHeight,\n        _ref2$rotate = _ref2.rotate,\n        rotate = _ref2$rotate === void 0 ? 0 : _ref2$rotate,\n        _ref2$scaleX = _ref2.scaleX,\n        scaleX = _ref2$scaleX === void 0 ? 1 : _ref2$scaleX,\n        _ref2$scaleY = _ref2.scaleY,\n        scaleY = _ref2$scaleY === void 0 ? 1 : _ref2$scaleY;\n      var file = this.file,\n        image = this.image,\n        options = this.options;\n      var canvas = document.createElement('canvas');\n      var context = canvas.getContext('2d');\n      var is90DegreesRotated = Math.abs(rotate) % 180 === 90;\n      var resizable = (options.resize === 'contain' || options.resize === 'cover') && isPositiveNumber(options.width) && isPositiveNumber(options.height);\n      var maxWidth = Math.max(options.maxWidth, 0) || Infinity;\n      var maxHeight = Math.max(options.maxHeight, 0) || Infinity;\n      var minWidth = Math.max(options.minWidth, 0) || 0;\n      var minHeight = Math.max(options.minHeight, 0) || 0;\n      var aspectRatio = naturalWidth / naturalHeight;\n      var width = options.width,\n        height = options.height;\n      if (is90DegreesRotated) {\n        var _ref3 = [maxHeight, maxWidth];\n        maxWidth = _ref3[0];\n        maxHeight = _ref3[1];\n        var _ref4 = [minHeight, minWidth];\n        minWidth = _ref4[0];\n        minHeight = _ref4[1];\n        var _ref5 = [height, width];\n        width = _ref5[0];\n        height = _ref5[1];\n      }\n      if (resizable) {\n        aspectRatio = width / height;\n      }\n      var _getAdjustedSizes = getAdjustedSizes({\n        aspectRatio: aspectRatio,\n        width: maxWidth,\n        height: maxHeight\n      }, 'contain');\n      maxWidth = _getAdjustedSizes.width;\n      maxHeight = _getAdjustedSizes.height;\n      var _getAdjustedSizes2 = getAdjustedSizes({\n        aspectRatio: aspectRatio,\n        width: minWidth,\n        height: minHeight\n      }, 'cover');\n      minWidth = _getAdjustedSizes2.width;\n      minHeight = _getAdjustedSizes2.height;\n      if (resizable) {\n        var _getAdjustedSizes3 = getAdjustedSizes({\n          aspectRatio: aspectRatio,\n          width: width,\n          height: height\n        }, options.resize);\n        width = _getAdjustedSizes3.width;\n        height = _getAdjustedSizes3.height;\n      } else {\n        var _getAdjustedSizes4 = getAdjustedSizes({\n          aspectRatio: aspectRatio,\n          width: width,\n          height: height\n        });\n        var _getAdjustedSizes4$wi = _getAdjustedSizes4.width;\n        width = _getAdjustedSizes4$wi === void 0 ? naturalWidth : _getAdjustedSizes4$wi;\n        var _getAdjustedSizes4$he = _getAdjustedSizes4.height;\n        height = _getAdjustedSizes4$he === void 0 ? naturalHeight : _getAdjustedSizes4$he;\n      }\n      width = Math.floor(normalizeDecimalNumber(Math.min(Math.max(width, minWidth), maxWidth)));\n      height = Math.floor(normalizeDecimalNumber(Math.min(Math.max(height, minHeight), maxHeight)));\n      var destX = -width / 2;\n      var destY = -height / 2;\n      var destWidth = width;\n      var destHeight = height;\n      var params = [];\n      if (resizable) {\n        var srcX = 0;\n        var srcY = 0;\n        var srcWidth = naturalWidth;\n        var srcHeight = naturalHeight;\n        var _getAdjustedSizes5 = getAdjustedSizes({\n          aspectRatio: aspectRatio,\n          width: naturalWidth,\n          height: naturalHeight\n        }, {\n          contain: 'cover',\n          cover: 'contain'\n        }[options.resize]);\n        srcWidth = _getAdjustedSizes5.width;\n        srcHeight = _getAdjustedSizes5.height;\n        srcX = (naturalWidth - srcWidth) / 2;\n        srcY = (naturalHeight - srcHeight) / 2;\n        params.push(srcX, srcY, srcWidth, srcHeight);\n      }\n      params.push(destX, destY, destWidth, destHeight);\n      if (is90DegreesRotated) {\n        var _ref6 = [height, width];\n        width = _ref6[0];\n        height = _ref6[1];\n      }\n      canvas.width = width;\n      canvas.height = height;\n      if (!isImageType(options.mimeType)) {\n        options.mimeType = file.type;\n      }\n      var fillStyle = 'transparent';\n\n      // Converts PNG files over the `convertSize` to JPEGs.\n      if (file.size > options.convertSize && options.convertTypes.indexOf(options.mimeType) >= 0) {\n        options.mimeType = 'image/jpeg';\n      }\n      var isJPEGImage = options.mimeType === 'image/jpeg';\n      if (isJPEGImage) {\n        fillStyle = '#fff';\n      }\n\n      // Override the default fill color (#000, black)\n      context.fillStyle = fillStyle;\n      context.fillRect(0, 0, width, height);\n      if (options.beforeDraw) {\n        options.beforeDraw.call(this, context, canvas);\n      }\n      if (this.aborted) {\n        return;\n      }\n      context.save();\n      context.translate(width / 2, height / 2);\n      context.rotate(rotate * Math.PI / 180);\n      context.scale(scaleX, scaleY);\n      context.drawImage.apply(context, [image].concat(params));\n      context.restore();\n      if (options.drew) {\n        options.drew.call(this, context, canvas);\n      }\n      if (this.aborted) {\n        return;\n      }\n      var callback = function callback(blob) {\n        if (!_this3.aborted) {\n          var done = function done(result) {\n            return _this3.done({\n              naturalWidth: naturalWidth,\n              naturalHeight: naturalHeight,\n              result: result\n            });\n          };\n          if (blob && isJPEGImage && options.retainExif && _this3.exif && _this3.exif.length > 0) {\n            var next = function next(arrayBuffer) {\n              return done(toBlob(arrayBufferToDataURL(insertExif(arrayBuffer, _this3.exif), options.mimeType)));\n            };\n            if (blob.arrayBuffer) {\n              blob.arrayBuffer().then(next).catch(function () {\n                _this3.fail(new Error('Failed to read the compressed image with Blob.arrayBuffer().'));\n              });\n            } else {\n              var reader = new FileReader();\n              _this3.reader = reader;\n              reader.onload = function (_ref7) {\n                var target = _ref7.target;\n                next(target.result);\n              };\n              reader.onabort = function () {\n                _this3.fail(new Error('Aborted to read the compressed image with FileReader.'));\n              };\n              reader.onerror = function () {\n                _this3.fail(new Error('Failed to read the compressed image with FileReader.'));\n              };\n              reader.onloadend = function () {\n                _this3.reader = null;\n              };\n              reader.readAsArrayBuffer(blob);\n            }\n          } else {\n            done(blob);\n          }\n        }\n      };\n      if (canvas.toBlob) {\n        canvas.toBlob(callback, options.mimeType, options.quality);\n      } else {\n        callback(toBlob(canvas.toDataURL(options.mimeType, options.quality)));\n      }\n    }\n  }, {\n    key: \"done\",\n    value: function done(_ref8) {\n      var naturalWidth = _ref8.naturalWidth,\n        naturalHeight = _ref8.naturalHeight,\n        result = _ref8.result;\n      var file = this.file,\n        image = this.image,\n        options = this.options;\n      if (URL && image.src.indexOf('blob:') === 0) {\n        URL.revokeObjectURL(image.src);\n      }\n      if (result) {\n        // Returns original file if the result is greater than it and without size related options\n        if (options.strict && !options.retainExif && result.size > file.size && options.mimeType === file.type && !(options.width > naturalWidth || options.height > naturalHeight || options.minWidth > naturalWidth || options.minHeight > naturalHeight || options.maxWidth < naturalWidth || options.maxHeight < naturalHeight)) {\n          result = file;\n        } else {\n          var date = new Date();\n          result.lastModified = date.getTime();\n          result.lastModifiedDate = date;\n          result.name = file.name;\n\n          // Convert the extension to match its type\n          if (result.name && result.type !== file.type) {\n            result.name = result.name.replace(REGEXP_EXTENSION, imageTypeToExtension(result.type));\n          }\n        }\n      } else {\n        // Returns original file if the result is null in some cases.\n        result = file;\n      }\n      this.result = result;\n      if (options.success) {\n        options.success.call(this, result);\n      }\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(err) {\n      var options = this.options;\n      if (options.error) {\n        options.error.call(this, err);\n      } else {\n        throw err;\n      }\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      if (!this.aborted) {\n        this.aborted = true;\n        if (this.reader) {\n          this.reader.abort();\n        } else if (!this.image.complete) {\n          this.image.onload = null;\n          this.image.onabort();\n        } else {\n          this.fail(new Error('The compression process has been aborted.'));\n        }\n      }\n    }\n\n    /**\n     * Get the no conflict compressor class.\n     * @returns {Compressor} The compressor class.\n     */\n  }], [{\n    key: \"noConflict\",\n    value: function noConflict() {\n      window.Compressor = AnotherCompressor;\n      return Compressor;\n    }\n\n    /**\n     * Change the default options.\n     * @param {Object} options - The new default options.\n     */\n  }, {\n    key: \"setDefaults\",\n    value: function setDefaults(options) {\n      _extends(DEFAULTS, options);\n    }\n  }]);\n  return Compressor;\n}();\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29tcHJlc3NvcmpzL2Rpc3QvY29tcHJlc3Nvci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFZ0MiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQTQ3MDM0M1xcc291cmNlXFxmcm9udGVuZFxcemlhZHBvcnRmb2xpb1xcbm9kZV9tb2R1bGVzXFxjb21wcmVzc29yanNcXGRpc3RcXGNvbXByZXNzb3IuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29tcHJlc3Nvci5qcyB2MS4yLjFcbiAqIGh0dHBzOi8vZmVuZ3l1YW5jaGVuLmdpdGh1Yi5pby9jb21wcmVzc29yanNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxOC1wcmVzZW50IENoZW4gRmVuZ3l1YW5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMjMtMDItMjhUMTQ6MDk6NDEuNzMyWlxuICovXG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxudmFyIGNhbnZhc1RvQmxvYiA9IHtleHBvcnRzOiB7fX07XG5cbi8qXG4gKiBKYXZhU2NyaXB0IENhbnZhcyB0byBCbG9iXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LUNhbnZhcy10by1CbG9iXG4gKlxuICogQ29weXJpZ2h0IDIwMTIsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICpcbiAqIEJhc2VkIG9uIHN0YWNrb3ZlcmZsb3cgdXNlciBTdG9pdmUncyBjb2RlIHNuaXBwZXQ6XG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcS80OTk4OTA4XG4gKi9cbihmdW5jdGlvbiAobW9kdWxlKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICAoZnVuY3Rpb24gKHdpbmRvdykge1xuXG4gICAgdmFyIENhbnZhc1Byb3RvdHlwZSA9IHdpbmRvdy5IVE1MQ2FudmFzRWxlbWVudCAmJiB3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlO1xuICAgIHZhciBoYXNCbG9iQ29uc3RydWN0b3IgPSB3aW5kb3cuQmxvYiAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihuZXcgQmxvYigpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0oKTtcbiAgICB2YXIgaGFzQXJyYXlCdWZmZXJWaWV3U3VwcG9ydCA9IGhhc0Jsb2JDb25zdHJ1Y3RvciAmJiB3aW5kb3cuVWludDhBcnJheSAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KDEwMCldKS5zaXplID09PSAxMDA7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KCk7XG4gICAgdmFyIEJsb2JCdWlsZGVyID0gd2luZG93LkJsb2JCdWlsZGVyIHx8IHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fCB3aW5kb3cuTW96QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1TQmxvYkJ1aWxkZXI7XG4gICAgdmFyIGRhdGFVUklQYXR0ZXJuID0gL15kYXRhOigoLio/KSg7Y2hhcnNldD0uKj8pPykoO2Jhc2U2NCk/LC87XG4gICAgdmFyIGRhdGFVUkx0b0Jsb2IgPSAoaGFzQmxvYkNvbnN0cnVjdG9yIHx8IEJsb2JCdWlsZGVyKSAmJiB3aW5kb3cuYXRvYiAmJiB3aW5kb3cuQXJyYXlCdWZmZXIgJiYgd2luZG93LlVpbnQ4QXJyYXkgJiYgZnVuY3Rpb24gKGRhdGFVUkkpIHtcbiAgICAgIHZhciBtYXRjaGVzLCBtZWRpYVR5cGUsIGlzQmFzZTY0LCBkYXRhU3RyaW5nLCBieXRlU3RyaW5nLCBhcnJheUJ1ZmZlciwgaW50QXJyYXksIGksIGJiO1xuICAgICAgLy8gUGFyc2UgdGhlIGRhdGFVUkkgY29tcG9uZW50cyBhcyBwZXIgUkZDIDIzOTdcbiAgICAgIG1hdGNoZXMgPSBkYXRhVVJJLm1hdGNoKGRhdGFVUklQYXR0ZXJuKTtcbiAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGF0YSBVUkknKTtcbiAgICAgIH1cbiAgICAgIC8vIERlZmF1bHQgdG8gdGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJXG4gICAgICBtZWRpYVR5cGUgPSBtYXRjaGVzWzJdID8gbWF0Y2hlc1sxXSA6ICd0ZXh0L3BsYWluJyArIChtYXRjaGVzWzNdIHx8ICc7Y2hhcnNldD1VUy1BU0NJSScpO1xuICAgICAgaXNCYXNlNjQgPSAhIW1hdGNoZXNbNF07XG4gICAgICBkYXRhU3RyaW5nID0gZGF0YVVSSS5zbGljZShtYXRjaGVzWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoaXNCYXNlNjQpIHtcbiAgICAgICAgLy8gQ29udmVydCBiYXNlNjQgdG8gcmF3IGJpbmFyeSBkYXRhIGhlbGQgaW4gYSBzdHJpbmc6XG4gICAgICAgIGJ5dGVTdHJpbmcgPSBhdG9iKGRhdGFTdHJpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29udmVydCBiYXNlNjQvVVJMRW5jb2RlZCBkYXRhIGNvbXBvbmVudCB0byByYXcgYmluYXJ5OlxuICAgICAgICBieXRlU3RyaW5nID0gZGVjb2RlVVJJQ29tcG9uZW50KGRhdGFTdHJpbmcpO1xuICAgICAgfVxuICAgICAgLy8gV3JpdGUgdGhlIGJ5dGVzIG9mIHRoZSBzdHJpbmcgdG8gYW4gQXJyYXlCdWZmZXI6XG4gICAgICBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlU3RyaW5nLmxlbmd0aCk7XG4gICAgICBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGludEFycmF5W2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuICAgICAgLy8gV3JpdGUgdGhlIEFycmF5QnVmZmVyIChvciBBcnJheUJ1ZmZlclZpZXcpIHRvIGEgYmxvYjpcbiAgICAgIGlmIChoYXNCbG9iQ29uc3RydWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFtoYXNBcnJheUJ1ZmZlclZpZXdTdXBwb3J0ID8gaW50QXJyYXkgOiBhcnJheUJ1ZmZlcl0sIHtcbiAgICAgICAgICB0eXBlOiBtZWRpYVR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBiYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xuICAgICAgYmIuYXBwZW5kKGFycmF5QnVmZmVyKTtcbiAgICAgIHJldHVybiBiYi5nZXRCbG9iKG1lZGlhVHlwZSk7XG4gICAgfTtcbiAgICBpZiAod2luZG93LkhUTUxDYW52YXNFbGVtZW50ICYmICFDYW52YXNQcm90b3R5cGUudG9CbG9iKSB7XG4gICAgICBpZiAoQ2FudmFzUHJvdG90eXBlLm1vekdldEFzRmlsZSkge1xuICAgICAgICBDYW52YXNQcm90b3R5cGUudG9CbG9iID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0eXBlLCBxdWFsaXR5KSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHF1YWxpdHkgJiYgQ2FudmFzUHJvdG90eXBlLnRvRGF0YVVSTCAmJiBkYXRhVVJMdG9CbG9iKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGFVUkx0b0Jsb2Ioc2VsZi50b0RhdGFVUkwodHlwZSwgcXVhbGl0eSkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHNlbGYubW96R2V0QXNGaWxlKCdibG9iJywgdHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChDYW52YXNQcm90b3R5cGUudG9EYXRhVVJMICYmIGRhdGFVUkx0b0Jsb2IpIHtcbiAgICAgICAgaWYgKENhbnZhc1Byb3RvdHlwZS5tc1RvQmxvYikge1xuICAgICAgICAgIENhbnZhc1Byb3RvdHlwZS50b0Jsb2IgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHR5cGUsIHF1YWxpdHkpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoKHR5cGUgJiYgdHlwZSAhPT0gJ2ltYWdlL3BuZycgfHwgcXVhbGl0eSkgJiYgQ2FudmFzUHJvdG90eXBlLnRvRGF0YVVSTCAmJiBkYXRhVVJMdG9CbG9iKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YVVSTHRvQmxvYihzZWxmLnRvRGF0YVVSTCh0eXBlLCBxdWFsaXR5KSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNlbGYubXNUb0Jsb2IodHlwZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIENhbnZhc1Byb3RvdHlwZS50b0Jsb2IgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHR5cGUsIHF1YWxpdHkpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhVVJMdG9CbG9iKHNlbGYudG9EYXRhVVJMKHR5cGUsIHF1YWxpdHkpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtb2R1bGUuZXhwb3J0cykge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkYXRhVVJMdG9CbG9iO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuZGF0YVVSTHRvQmxvYiA9IGRhdGFVUkx0b0Jsb2I7XG4gICAgfVxuICB9KSh3aW5kb3cpO1xufSkoY2FudmFzVG9CbG9iKTtcbnZhciB0b0Jsb2IgPSBjYW52YXNUb0Jsb2IuZXhwb3J0cztcblxudmFyIGlzQmxvYiA9IGZ1bmN0aW9uIGlzQmxvYih2YWx1ZSkge1xuICBpZiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEJsb2IgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufTtcblxudmFyIERFRkFVTFRTID0ge1xuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIG91dHB1dCB0aGUgb3JpZ2luYWwgaW1hZ2UgaW5zdGVhZCBvZiB0aGUgY29tcHJlc3NlZCBvbmVcbiAgICogd2hlbiB0aGUgc2l6ZSBvZiB0aGUgY29tcHJlc3NlZCBpbWFnZSBpcyBncmVhdGVyIHRoYW4gdGhlIG9yaWdpbmFsIG9uZSdzXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc3RyaWN0OiB0cnVlLFxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHJlYWQgdGhlIGltYWdlJ3MgRXhpZiBPcmllbnRhdGlvbiBpbmZvcm1hdGlvbixcbiAgICogYW5kIHRoZW4gcm90YXRlIG9yIGZsaXAgdGhlIGltYWdlIGF1dG9tYXRpY2FsbHkuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgY2hlY2tPcmllbnRhdGlvbjogdHJ1ZSxcbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiByZXRhaW4gdGhlIGltYWdlJ3MgRXhpZiBpbmZvcm1hdGlvbiBhZnRlciBjb21wcmVzc2VkLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgKi9cbiAgcmV0YWluRXhpZjogZmFsc2UsXG4gIC8qKlxuICAgKiBUaGUgbWF4IHdpZHRoIG9mIHRoZSBvdXRwdXQgaW1hZ2UuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBtYXhXaWR0aDogSW5maW5pdHksXG4gIC8qKlxuICAgKiBUaGUgbWF4IGhlaWdodCBvZiB0aGUgb3V0cHV0IGltYWdlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbWF4SGVpZ2h0OiBJbmZpbml0eSxcbiAgLyoqXG4gICAqIFRoZSBtaW4gd2lkdGggb2YgdGhlIG91dHB1dCBpbWFnZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIG1pbldpZHRoOiAwLFxuICAvKipcbiAgICogVGhlIG1pbiBoZWlnaHQgb2YgdGhlIG91dHB1dCBpbWFnZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIG1pbkhlaWdodDogMCxcbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiB0aGUgb3V0cHV0IGltYWdlLlxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgbmF0dXJhbCB3aWR0aCBvZiB0aGUgc291cmNlIGltYWdlIHdpbGwgYmUgdXNlZC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHdpZHRoOiB1bmRlZmluZWQsXG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgaW1hZ2UuXG4gICAqIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBuYXR1cmFsIGhlaWdodCBvZiB0aGUgc291cmNlIGltYWdlIHdpbGwgYmUgdXNlZC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGhlaWdodDogdW5kZWZpbmVkLFxuICAvKipcbiAgICogU2V0cyBob3cgdGhlIHNpemUgb2YgdGhlIGltYWdlIHNob3VsZCBiZSByZXNpemVkIHRvIHRoZSBjb250YWluZXJcbiAgICogc3BlY2lmaWVkIGJ5IHRoZSBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBvcHRpb25zLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgcmVzaXplOiAnbm9uZScsXG4gIC8qKlxuICAgKiBUaGUgcXVhbGl0eSBvZiB0aGUgb3V0cHV0IGltYWdlLlxuICAgKiBJdCBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCBgMWAsXG4gICAqIGFuZCBvbmx5IGF2YWlsYWJsZSBmb3IgYGltYWdlL2pwZWdgIGFuZCBgaW1hZ2Uvd2VicGAgaW1hZ2VzLlxuICAgKiBDaGVjayBvdXQge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MQ2FudmFzRWxlbWVudC90b0Jsb2IgY2FudmFzLnRvQmxvYn0uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBxdWFsaXR5OiAwLjgsXG4gIC8qKlxuICAgKiBUaGUgbWltZSB0eXBlIG9mIHRoZSBvdXRwdXQgaW1hZ2UuXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBvcmlnaW5hbCBtaW1lIHR5cGUgb2YgdGhlIHNvdXJjZSBpbWFnZSBmaWxlIHdpbGwgYmUgdXNlZC5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIG1pbWVUeXBlOiAnYXV0bycsXG4gIC8qKlxuICAgKiBGaWxlcyB3aG9zZSBmaWxlIHR5cGUgaXMgaW5jbHVkZWQgaW4gdGhpcyBsaXN0LFxuICAgKiBhbmQgd2hvc2UgZmlsZSBzaXplIGV4Y2VlZHMgdGhlIGBjb252ZXJ0U2l6ZWAgdmFsdWUgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gSlBFR3MuXG4gICAqIEB0eXBlIHtzdHJpbmfvvZxBcnJheX1cbiAgICovXG4gIGNvbnZlcnRUeXBlczogWydpbWFnZS9wbmcnXSxcbiAgLyoqXG4gICAqIFBORyBmaWxlcyBvdmVyIHRoaXMgc2l6ZSAoNSBNQiBieSBkZWZhdWx0KSB3aWxsIGJlIGNvbnZlcnRlZCB0byBKUEVHcy5cbiAgICogVG8gZGlzYWJsZSB0aGlzLCBqdXN0IHNldCB0aGUgdmFsdWUgdG8gYEluZmluaXR5YC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGNvbnZlcnRTaXplOiA1MDAwMDAwLFxuICAvKipcbiAgICogVGhlIGhvb2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBiZWZvcmUgZHJhdyB0aGUgaW1hZ2UgaW50byB0aGUgY2FudmFzIGZvciBjb21wcmVzc2lvbi5cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSAyZCByZW5kZXJpbmcgY29udGV4dCBvZiB0aGUgY2FudmFzLlxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIGZvciBjb21wcmVzc2lvbi5cbiAgICogQGV4YW1wbGVcbiAgICogZnVuY3Rpb24gKGNvbnRleHQsIGNhbnZhcykge1xuICAgKiAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyNmZmYnO1xuICAgKiB9XG4gICAqL1xuICBiZWZvcmVEcmF3OiBudWxsLFxuICAvKipcbiAgICogVGhlIGhvb2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciBkcmV3IHRoZSBpbWFnZSBpbnRvIHRoZSBjYW52YXMgZm9yIGNvbXByZXNzaW9uLlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IC0gVGhlIDJkIHJlbmRlcmluZyBjb250ZXh0IG9mIHRoZSBjYW52YXMuXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIFRoZSBjYW52YXMgZm9yIGNvbXByZXNzaW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKiBmdW5jdGlvbiAoY29udGV4dCwgY2FudmFzKSB7XG4gICAqICAgY29udGV4dC5maWx0ZXIgPSAnZ3JheXNjYWxlKDEwMCUpJztcbiAgICogfVxuICAgKi9cbiAgZHJldzogbnVsbCxcbiAgLyoqXG4gICAqIFRoZSBob29rIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiBzdWNjZXNzIHRvIGNvbXByZXNzIHRoZSBpbWFnZS5cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0ge0ZpbGV9IGZpbGUgLSBUaGUgY29tcHJlc3NlZCBpbWFnZSBGaWxlIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICogZnVuY3Rpb24gKGZpbGUpIHtcbiAgICogICBjb25zb2xlLmxvZyhmaWxlKTtcbiAgICogfVxuICAgKi9cbiAgc3VjY2VzczogbnVsbCxcbiAgLyoqXG4gICAqIFRoZSBob29rIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiBmYWlsIHRvIGNvbXByZXNzIHRoZSBpbWFnZS5cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBBbiBFcnJvciBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGZ1bmN0aW9uIChlcnIpIHtcbiAgICogICBjb25zb2xlLmxvZyhlcnIubWVzc2FnZSk7XG4gICAqIH1cbiAgICovXG4gIGVycm9yOiBudWxsXG59O1xuXG52YXIgSVNfQlJPV1NFUiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIFdJTkRPVyA9IElTX0JST1dTRVIgPyB3aW5kb3cgOiB7fTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBwb3NpdGl2ZSBudW1iZXIuXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBvc2l0aXZlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICovXG52YXIgaXNQb3NpdGl2ZU51bWJlciA9IGZ1bmN0aW9uIGlzUG9zaXRpdmVOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID4gMCAmJiB2YWx1ZSA8IEluZmluaXR5O1xufTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5LWxpa2Ugb3IgaXRlcmFibGUgb2JqZWN0IHRvIGFuIGFycmF5LlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5mcm9tID8gQXJyYXkuZnJvbSh2YWx1ZSkgOiBzbGljZS5jYWxsKHZhbHVlKTtcbn1cbnZhciBSRUdFWFBfSU1BR0VfVFlQRSA9IC9eaW1hZ2VcXC8uKyQvO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIG1pbWUgdHlwZSBvZiBpbWFnZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGlzIGEgbWltZSB0eXBlIG9mIGltYWdlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW1hZ2VUeXBlKHZhbHVlKSB7XG4gIHJldHVybiBSRUdFWFBfSU1BR0VfVFlQRS50ZXN0KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGltYWdlIHR5cGUgdG8gZXh0ZW5zaW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIGltYWdlIHR5cGUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRoZSBpbWFnZSBleHRlbnNpb24uXG4gKi9cbmZ1bmN0aW9uIGltYWdlVHlwZVRvRXh0ZW5zaW9uKHZhbHVlKSB7XG4gIHZhciBleHRlbnNpb24gPSBpc0ltYWdlVHlwZSh2YWx1ZSkgPyB2YWx1ZS5zdWJzdHIoNikgOiAnJztcbiAgaWYgKGV4dGVuc2lvbiA9PT0gJ2pwZWcnKSB7XG4gICAgZXh0ZW5zaW9uID0gJ2pwZyc7XG4gIH1cbiAgcmV0dXJuIFwiLlwiLmNvbmNhdChleHRlbnNpb24pO1xufVxudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8qKlxuICogR2V0IHN0cmluZyBmcm9tIGNoYXIgY29kZSBpbiBkYXRhIHZpZXcuXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlldyAtIFRoZSBkYXRhIHZpZXcgZm9yIHJlYWQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBUaGUgc3RhcnQgaW5kZXguXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIC0gVGhlIHJlYWQgbGVuZ3RoLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHJlYWQgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tQ2hhckNvZGUoZGF0YVZpZXcsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgaTtcbiAgbGVuZ3RoICs9IHN0YXJ0O1xuICBmb3IgKGkgPSBzdGFydDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgc3RyICs9IGZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChpKSk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbnZhciBidG9hID0gV0lORE9XLmJ0b2E7XG5cbi8qKlxuICogVHJhbnNmb3JtIGFycmF5IGJ1ZmZlciB0byBEYXRhIFVSTC5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIC0gVGhlIGFycmF5IGJ1ZmZlciB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWltZVR5cGUgLSBUaGUgbWltZSB0eXBlIG9mIHRoZSBEYXRhIFVSTC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSByZXN1bHQgRGF0YSBVUkwuXG4gKi9cbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9EYXRhVVJMKGFycmF5QnVmZmVyLCBtaW1lVHlwZSkge1xuICB2YXIgY2h1bmtzID0gW107XG4gIHZhciBjaHVua1NpemUgPSA4MTkyO1xuICB2YXIgdWludDggPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gIHdoaWxlICh1aW50OC5sZW5ndGggPiAwKSB7XG4gICAgLy8gWFhYOiBCYWJlbCdzIGB0b0NvbnN1bWFibGVBcnJheWAgaGVscGVyIHdpbGwgdGhyb3cgZXJyb3IgaW4gSUUgb3IgU2FmYXJpIDlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgIGNodW5rcy5wdXNoKGZyb21DaGFyQ29kZS5hcHBseShudWxsLCB0b0FycmF5KHVpbnQ4LnN1YmFycmF5KDAsIGNodW5rU2l6ZSkpKSk7XG4gICAgdWludDggPSB1aW50OC5zdWJhcnJheShjaHVua1NpemUpO1xuICB9XG4gIHJldHVybiBcImRhdGE6XCIuY29uY2F0KG1pbWVUeXBlLCBcIjtiYXNlNjQsXCIpLmNvbmNhdChidG9hKGNodW5rcy5qb2luKCcnKSkpO1xufVxuXG4vKipcbiAqIEdldCBvcmllbnRhdGlvbiB2YWx1ZSBmcm9tIGdpdmVuIGFycmF5IGJ1ZmZlci5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIC0gVGhlIGFycmF5IGJ1ZmZlciB0byByZWFkLlxuICogQHJldHVybnMge251bWJlcn0gVGhlIHJlYWQgb3JpZW50YXRpb24gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0QW5kR2V0T3JpZW50YXRpb24oYXJyYXlCdWZmZXIpIHtcbiAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgdmFyIG9yaWVudGF0aW9uO1xuXG4gIC8vIElnbm9yZXMgcmFuZ2UgZXJyb3Igd2hlbiB0aGUgaW1hZ2UgZG9lcyBub3QgaGF2ZSBjb3JyZWN0IEV4aWYgaW5mb3JtYXRpb25cbiAgdHJ5IHtcbiAgICB2YXIgbGl0dGxlRW5kaWFuO1xuICAgIHZhciBhcHAxU3RhcnQ7XG4gICAgdmFyIGlmZFN0YXJ0O1xuXG4gICAgLy8gT25seSBoYW5kbGUgSlBFRyBpbWFnZSAoc3RhcnQgYnkgMHhGRkQ4KVxuICAgIGlmIChkYXRhVmlldy5nZXRVaW50OCgwKSA9PT0gMHhGRiAmJiBkYXRhVmlldy5nZXRVaW50OCgxKSA9PT0gMHhEOCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGRhdGFWaWV3LmJ5dGVMZW5ndGg7XG4gICAgICB2YXIgb2Zmc2V0ID0gMjtcbiAgICAgIHdoaWxlIChvZmZzZXQgKyAxIDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpID09PSAweEZGICYmIGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDEpID09PSAweEUxKSB7XG4gICAgICAgICAgYXBwMVN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXBwMVN0YXJ0KSB7XG4gICAgICB2YXIgZXhpZklEQ29kZSA9IGFwcDFTdGFydCArIDQ7XG4gICAgICB2YXIgdGlmZk9mZnNldCA9IGFwcDFTdGFydCArIDEwO1xuICAgICAgaWYgKGdldFN0cmluZ0Zyb21DaGFyQ29kZShkYXRhVmlldywgZXhpZklEQ29kZSwgNCkgPT09ICdFeGlmJykge1xuICAgICAgICB2YXIgZW5kaWFubmVzcyA9IGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0KTtcbiAgICAgICAgbGl0dGxlRW5kaWFuID0gZW5kaWFubmVzcyA9PT0gMHg0OTQ5O1xuICAgICAgICBpZiAobGl0dGxlRW5kaWFuIHx8IGVuZGlhbm5lc3MgPT09IDB4NEQ0RCAvKiBiaWdFbmRpYW4gKi8pIHtcbiAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZPZmZzZXQgKyAyLCBsaXR0bGVFbmRpYW4pID09PSAweDAwMkEpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdElGRE9mZnNldCA9IGRhdGFWaWV3LmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgIGlmIChmaXJzdElGRE9mZnNldCA+PSAweDAwMDAwMDA4KSB7XG4gICAgICAgICAgICAgIGlmZFN0YXJ0ID0gdGlmZk9mZnNldCArIGZpcnN0SUZET2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaWZkU3RhcnQpIHtcbiAgICAgIHZhciBfbGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDE2KGlmZFN0YXJ0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgdmFyIF9vZmZzZXQ7XG4gICAgICB2YXIgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBfbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgX29mZnNldCA9IGlmZFN0YXJ0ICsgaSAqIDEyICsgMjtcbiAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNihfb2Zmc2V0LCBsaXR0bGVFbmRpYW4pID09PSAweDAxMTIgLyogT3JpZW50YXRpb24gKi8pIHtcbiAgICAgICAgICAvLyA4IGlzIHRoZSBvZmZzZXQgb2YgdGhlIGN1cnJlbnQgdGFnJ3MgdmFsdWVcbiAgICAgICAgICBfb2Zmc2V0ICs9IDg7XG5cbiAgICAgICAgICAvLyBHZXQgdGhlIG9yaWdpbmFsIG9yaWVudGF0aW9uIHZhbHVlXG4gICAgICAgICAgb3JpZW50YXRpb24gPSBkYXRhVmlldy5nZXRVaW50MTYoX29mZnNldCwgbGl0dGxlRW5kaWFuKTtcblxuICAgICAgICAgIC8vIE92ZXJyaWRlIHRoZSBvcmllbnRhdGlvbiB3aXRoIGl0cyBkZWZhdWx0IHZhbHVlXG4gICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KF9vZmZzZXQsIDEsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBvcmllbnRhdGlvbiA9IDE7XG4gIH1cbiAgcmV0dXJuIG9yaWVudGF0aW9uO1xufVxuXG4vKipcbiAqIFBhcnNlIEV4aWYgT3JpZW50YXRpb24gdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gb3JpZW50YXRpb24gLSBUaGUgb3JpZW50YXRpb24gdG8gcGFyc2UuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcGFyc2VkIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VPcmllbnRhdGlvbihvcmllbnRhdGlvbikge1xuICB2YXIgcm90YXRlID0gMDtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XG4gICAgLy8gRmxpcCBob3Jpem9udGFsXG4gICAgY2FzZSAyOlxuICAgICAgc2NhbGVYID0gLTE7XG4gICAgICBicmVhaztcblxuICAgIC8vIFJvdGF0ZSBsZWZ0IDE4MMKwXG4gICAgY2FzZSAzOlxuICAgICAgcm90YXRlID0gLTE4MDtcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gRmxpcCB2ZXJ0aWNhbFxuICAgIGNhc2UgNDpcbiAgICAgIHNjYWxlWSA9IC0xO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBGbGlwIHZlcnRpY2FsIGFuZCByb3RhdGUgcmlnaHQgOTDCsFxuICAgIGNhc2UgNTpcbiAgICAgIHJvdGF0ZSA9IDkwO1xuICAgICAgc2NhbGVZID0gLTE7XG4gICAgICBicmVhaztcblxuICAgIC8vIFJvdGF0ZSByaWdodCA5MMKwXG4gICAgY2FzZSA2OlxuICAgICAgcm90YXRlID0gOTA7XG4gICAgICBicmVhaztcblxuICAgIC8vIEZsaXAgaG9yaXpvbnRhbCBhbmQgcm90YXRlIHJpZ2h0IDkwwrBcbiAgICBjYXNlIDc6XG4gICAgICByb3RhdGUgPSA5MDtcbiAgICAgIHNjYWxlWCA9IC0xO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBSb3RhdGUgbGVmdCA5MMKwXG4gICAgY2FzZSA4OlxuICAgICAgcm90YXRlID0gLTkwO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByb3RhdGU6IHJvdGF0ZSxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWVxuICB9O1xufVxudmFyIFJFR0VYUF9ERUNJTUFMUyA9IC9cXC5cXGQqKD86MHw5KXsxMn1cXGQqJC87XG5cbi8qKlxuICogTm9ybWFsaXplIGRlY2ltYWwgbnVtYmVyLlxuICogQ2hlY2sgb3V0IHtAbGluayBodHRwczovLzAuMzAwMDAwMDAwMDAwMDAwMDQuY29tL31cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBub3JtYWxpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3RpbWVzPTEwMDAwMDAwMDAwMF0gLSBUaGUgdGltZXMgZm9yIG5vcm1hbGl6aW5nLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbm9ybWFsaXplZCBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURlY2ltYWxOdW1iZXIodmFsdWUpIHtcbiAgdmFyIHRpbWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxMDAwMDAwMDAwMDA7XG4gIHJldHVybiBSRUdFWFBfREVDSU1BTFMudGVzdCh2YWx1ZSkgPyBNYXRoLnJvdW5kKHZhbHVlICogdGltZXMpIC8gdGltZXMgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG1heCBzaXplcyBpbiBhIHJlY3RhbmdsZSB1bmRlciB0aGUgZ2l2ZW4gYXNwZWN0IHJhdGlvLlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgb3JpZ2luYWwgc2l6ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9J2NvbnRhaW4nXSAtIFRoZSBhZGp1c3QgdHlwZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHQgc2l6ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldEFkanVzdGVkU2l6ZXMoX3JlZikge1xuICB2YXIgYXNwZWN0UmF0aW8gPSBfcmVmLmFzcGVjdFJhdGlvLFxuICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgIHdpZHRoID0gX3JlZi53aWR0aDtcbiAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdub25lJztcbiAgdmFyIGlzVmFsaWRXaWR0aCA9IGlzUG9zaXRpdmVOdW1iZXIod2lkdGgpO1xuICB2YXIgaXNWYWxpZEhlaWdodCA9IGlzUG9zaXRpdmVOdW1iZXIoaGVpZ2h0KTtcbiAgaWYgKGlzVmFsaWRXaWR0aCAmJiBpc1ZhbGlkSGVpZ2h0KSB7XG4gICAgdmFyIGFkanVzdGVkV2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICBpZiAoKHR5cGUgPT09ICdjb250YWluJyB8fCB0eXBlID09PSAnbm9uZScpICYmIGFkanVzdGVkV2lkdGggPiB3aWR0aCB8fCB0eXBlID09PSAnY292ZXInICYmIGFkanVzdGVkV2lkdGggPCB3aWR0aCkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZFdpZHRoKSB7XG4gICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3RSYXRpbztcbiAgfSBlbHNlIGlmIChpc1ZhbGlkSGVpZ2h0KSB7XG4gICAgd2lkdGggPSBoZWlnaHQgKiBhc3BlY3RSYXRpbztcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuXG4vKipcbiAqIEdldCBFeGlmIGluZm9ybWF0aW9uIGZyb20gdGhlIGdpdmVuIGFycmF5IGJ1ZmZlci5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIC0gVGhlIGFycmF5IGJ1ZmZlciB0byByZWFkLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVhZCBFeGlmIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRFeGlmKGFycmF5QnVmZmVyKSB7XG4gIHZhciBhcnJheSA9IHRvQXJyYXkobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIHNlZ21lbnRzID0gW107XG4gIHZhciBzdGFydCA9IDA7XG4gIHdoaWxlIChzdGFydCArIDMgPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtzdGFydF07XG4gICAgdmFyIG5leHQgPSBhcnJheVtzdGFydCArIDFdO1xuXG4gICAgLy8gU09TIChTdGFydCBvZiBTY2FuKVxuICAgIGlmICh2YWx1ZSA9PT0gMHhGRiAmJiBuZXh0ID09PSAweERBKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBTT0kgKFN0YXJ0IG9mIEltYWdlKVxuICAgIGlmICh2YWx1ZSA9PT0gMHhGRiAmJiBuZXh0ID09PSAweEQ4KSB7XG4gICAgICBzdGFydCArPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJyYXlbc3RhcnQgKyAyXSAqIDI1NiArIGFycmF5W3N0YXJ0ICsgM107XG4gICAgICB2YXIgZW5kID0gc3RhcnQgKyBvZmZzZXQgKyAyO1xuICAgICAgdmFyIHNlZ21lbnQgPSBhcnJheS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICBzdGFydCA9IGVuZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnRzLnJlZHVjZShmdW5jdGlvbiAoZXhpZkFycmF5LCBjdXJyZW50KSB7XG4gICAgaWYgKGN1cnJlbnRbMF0gPT09IDB4RkYgJiYgY3VycmVudFsxXSA9PT0gMHhFMSkge1xuICAgICAgcmV0dXJuIGV4aWZBcnJheS5jb25jYXQoY3VycmVudCk7XG4gICAgfVxuICAgIHJldHVybiBleGlmQXJyYXk7XG4gIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBJbnNlcnQgRXhpZiBpbmZvcm1hdGlvbiBpbnRvIHRoZSBnaXZlbiBhcnJheSBidWZmZXIuXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciAtIFRoZSBhcnJheSBidWZmZXIgdG8gdHJhbnNmb3JtLlxuICogQHBhcmFtIHtBcnJheX0gZXhpZkFycmF5IC0gVGhlIEV4aWYgaW5mb3JtYXRpb24gdG8gaW5zZXJ0LlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBUaGUgdHJhbnNmb3JtZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBpbnNlcnRFeGlmKGFycmF5QnVmZmVyLCBleGlmQXJyYXkpIHtcbiAgdmFyIGFycmF5ID0gdG9BcnJheShuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICBpZiAoYXJyYXlbMl0gIT09IDB4RkYgfHwgYXJyYXlbM10gIT09IDB4RTApIHtcbiAgICByZXR1cm4gYXJyYXlCdWZmZXI7XG4gIH1cbiAgdmFyIGFwcDBMZW5ndGggPSBhcnJheVs0XSAqIDI1NiArIGFycmF5WzVdO1xuICB2YXIgbmV3QXJyYXlCdWZmZXIgPSBbMHhGRiwgMHhEOF0uY29uY2F0KGV4aWZBcnJheSwgYXJyYXkuc2xpY2UoNCArIGFwcDBMZW5ndGgpKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ld0FycmF5QnVmZmVyKTtcbn1cblxudmFyIEFycmF5QnVmZmVyJDEgPSBXSU5ET1cuQXJyYXlCdWZmZXIsXG4gIEZpbGVSZWFkZXIgPSBXSU5ET1cuRmlsZVJlYWRlcjtcbnZhciBVUkwgPSBXSU5ET1cuVVJMIHx8IFdJTkRPVy53ZWJraXRVUkw7XG52YXIgUkVHRVhQX0VYVEVOU0lPTiA9IC9cXC5cXHcrJC87XG52YXIgQW5vdGhlckNvbXByZXNzb3IgPSBXSU5ET1cuQ29tcHJlc3NvcjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGltYWdlIGNvbXByZXNzb3IuXG4gKiBAY2xhc3NcbiAqL1xudmFyIENvbXByZXNzb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogVGhlIGNvbnN0cnVjdG9yIG9mIENvbXByZXNzb3IuXG4gICAqIEBwYXJhbSB7RmlsZXxCbG9ifSBmaWxlIC0gVGhlIHRhcmdldCBpbWFnZSBmaWxlIGZvciBjb21wcmVzc2luZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zIGZvciBjb21wcmVzc2luZy5cbiAgICovXG4gIGZ1bmN0aW9uIENvbXByZXNzb3IoZmlsZSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wcmVzc29yKTtcbiAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgIHRoaXMuZXhpZiA9IFtdO1xuICAgIHRoaXMuaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVFMpLCBvcHRpb25zKTtcbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKENvbXByZXNzb3IsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZSxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmICghaXNCbG9iKGZpbGUpKSB7XG4gICAgICAgIHRoaXMuZmFpbChuZXcgRXJyb3IoJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgRmlsZSBvciBCbG9iIG9iamVjdC4nKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtaW1lVHlwZSA9IGZpbGUudHlwZTtcbiAgICAgIGlmICghaXNJbWFnZVR5cGUobWltZVR5cGUpKSB7XG4gICAgICAgIHRoaXMuZmFpbChuZXcgRXJyb3IoJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGltYWdlIEZpbGUgb3IgQmxvYiBvYmplY3QuJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIVVSTCB8fCAhRmlsZVJlYWRlcikge1xuICAgICAgICB0aGlzLmZhaWwobmV3IEVycm9yKCdUaGUgY3VycmVudCBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgaW1hZ2UgY29tcHJlc3Npb24uJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5QnVmZmVyJDEpIHtcbiAgICAgICAgb3B0aW9ucy5jaGVja09yaWVudGF0aW9uID0gZmFsc2U7XG4gICAgICAgIG9wdGlvbnMucmV0YWluRXhpZiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGlzSlBFR0ltYWdlID0gbWltZVR5cGUgPT09ICdpbWFnZS9qcGVnJztcbiAgICAgIHZhciBjaGVja09yaWVudGF0aW9uID0gaXNKUEVHSW1hZ2UgJiYgb3B0aW9ucy5jaGVja09yaWVudGF0aW9uO1xuICAgICAgdmFyIHJldGFpbkV4aWYgPSBpc0pQRUdJbWFnZSAmJiBvcHRpb25zLnJldGFpbkV4aWY7XG4gICAgICBpZiAoVVJMICYmICFjaGVja09yaWVudGF0aW9uICYmICFyZXRhaW5FeGlmKSB7XG4gICAgICAgIHRoaXMubG9hZCh7XG4gICAgICAgICAgdXJsOiBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyO1xuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gX3JlZi50YXJnZXQ7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgICB2YXIgb3JpZW50YXRpb24gPSAxO1xuICAgICAgICAgIGlmIChjaGVja09yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgb3JpZW50YXRpb24gdmFsdWUgdG8gaXRzIGRlZmF1bHQgdmFsdWUgMVxuICAgICAgICAgICAgLy8gYXMgc29tZSBpT1MgYnJvd3NlcnMgd2lsbCByZW5kZXIgaW1hZ2Ugd2l0aCBpdHMgb3JpZW50YXRpb25cbiAgICAgICAgICAgIG9yaWVudGF0aW9uID0gcmVzZXRBbmRHZXRPcmllbnRhdGlvbihyZXN1bHQpO1xuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID4gMSkge1xuICAgICAgICAgICAgICBfZXh0ZW5kcyhkYXRhLCBwYXJzZU9yaWVudGF0aW9uKG9yaWVudGF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXRhaW5FeGlmKSB7XG4gICAgICAgICAgICBfdGhpcy5leGlmID0gZ2V0RXhpZihyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hlY2tPcmllbnRhdGlvbiB8fCByZXRhaW5FeGlmKSB7XG4gICAgICAgICAgICBpZiAoIVVSTFxuXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG5ldyBVUkwgd2l0aCB0aGUgZGVmYXVsdCBvcmllbnRhdGlvbiB2YWx1ZSAxLlxuICAgICAgICAgICAgfHwgb3JpZW50YXRpb24gPiAxKSB7XG4gICAgICAgICAgICAgIGRhdGEudXJsID0gYXJyYXlCdWZmZXJUb0RhdGFVUkwocmVzdWx0LCBtaW1lVHlwZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhLnVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEudXJsID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5sb2FkKGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5mYWlsKG5ldyBFcnJvcignQWJvcnRlZCB0byByZWFkIHRoZSBpbWFnZSB3aXRoIEZpbGVSZWFkZXIuJykpO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5mYWlsKG5ldyBFcnJvcignRmFpbGVkIHRvIHJlYWQgdGhlIGltYWdlIHdpdGggRmlsZVJlYWRlci4nKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMucmVhZGVyID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNoZWNrT3JpZW50YXRpb24gfHwgcmV0YWluRXhpZikge1xuICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQoZGF0YSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZSxcbiAgICAgICAgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuZHJhdyhfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGF0YSksIHt9LCB7XG4gICAgICAgICAgbmF0dXJhbFdpZHRoOiBpbWFnZS5uYXR1cmFsV2lkdGgsXG4gICAgICAgICAgbmF0dXJhbEhlaWdodDogaW1hZ2UubmF0dXJhbEhlaWdodFxuICAgICAgICB9KSk7XG4gICAgICB9O1xuICAgICAgaW1hZ2Uub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmZhaWwobmV3IEVycm9yKCdBYm9ydGVkIHRvIGxvYWQgdGhlIGltYWdlLicpKTtcbiAgICAgIH07XG4gICAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuZmFpbChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHRoZSBpbWFnZS4nKSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBNYXRjaCBhbGwgYnJvd3NlcnMgdGhhdCB1c2UgV2ViS2l0IGFzIHRoZSBsYXlvdXQgZW5naW5lIGluIGlPUyBkZXZpY2VzLFxuICAgICAgLy8gc3VjaCBhcyBTYWZhcmkgZm9yIGlPUywgQ2hyb21lIGZvciBpT1MsIGFuZCBpbi1hcHAgYnJvd3NlcnMuXG4gICAgICBpZiAoV0lORE9XLm5hdmlnYXRvciAmJiAvKD86aVBhZHxpUGhvbmV8aVBvZCkuKj9BcHBsZVdlYktpdC9pLnRlc3QoV0lORE9XLm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgIC8vIEZpeCB0aGUgYFRoZSBvcGVyYXRpb24gaXMgaW5zZWN1cmVgIGVycm9yICgjNTcpXG4gICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgICB9XG4gICAgICBpbWFnZS5hbHQgPSBmaWxlLm5hbWU7XG4gICAgICBpbWFnZS5zcmMgPSBkYXRhLnVybDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KF9yZWYyKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBuYXR1cmFsV2lkdGggPSBfcmVmMi5uYXR1cmFsV2lkdGgsXG4gICAgICAgIG5hdHVyYWxIZWlnaHQgPSBfcmVmMi5uYXR1cmFsSGVpZ2h0LFxuICAgICAgICBfcmVmMiRyb3RhdGUgPSBfcmVmMi5yb3RhdGUsXG4gICAgICAgIHJvdGF0ZSA9IF9yZWYyJHJvdGF0ZSA9PT0gdm9pZCAwID8gMCA6IF9yZWYyJHJvdGF0ZSxcbiAgICAgICAgX3JlZjIkc2NhbGVYID0gX3JlZjIuc2NhbGVYLFxuICAgICAgICBzY2FsZVggPSBfcmVmMiRzY2FsZVggPT09IHZvaWQgMCA/IDEgOiBfcmVmMiRzY2FsZVgsXG4gICAgICAgIF9yZWYyJHNjYWxlWSA9IF9yZWYyLnNjYWxlWSxcbiAgICAgICAgc2NhbGVZID0gX3JlZjIkc2NhbGVZID09PSB2b2lkIDAgPyAxIDogX3JlZjIkc2NhbGVZO1xuICAgICAgdmFyIGZpbGUgPSB0aGlzLmZpbGUsXG4gICAgICAgIGltYWdlID0gdGhpcy5pbWFnZSxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB2YXIgaXM5MERlZ3JlZXNSb3RhdGVkID0gTWF0aC5hYnMocm90YXRlKSAlIDE4MCA9PT0gOTA7XG4gICAgICB2YXIgcmVzaXphYmxlID0gKG9wdGlvbnMucmVzaXplID09PSAnY29udGFpbicgfHwgb3B0aW9ucy5yZXNpemUgPT09ICdjb3ZlcicpICYmIGlzUG9zaXRpdmVOdW1iZXIob3B0aW9ucy53aWR0aCkgJiYgaXNQb3NpdGl2ZU51bWJlcihvcHRpb25zLmhlaWdodCk7XG4gICAgICB2YXIgbWF4V2lkdGggPSBNYXRoLm1heChvcHRpb25zLm1heFdpZHRoLCAwKSB8fCBJbmZpbml0eTtcbiAgICAgIHZhciBtYXhIZWlnaHQgPSBNYXRoLm1heChvcHRpb25zLm1heEhlaWdodCwgMCkgfHwgSW5maW5pdHk7XG4gICAgICB2YXIgbWluV2lkdGggPSBNYXRoLm1heChvcHRpb25zLm1pbldpZHRoLCAwKSB8fCAwO1xuICAgICAgdmFyIG1pbkhlaWdodCA9IE1hdGgubWF4KG9wdGlvbnMubWluSGVpZ2h0LCAwKSB8fCAwO1xuICAgICAgdmFyIGFzcGVjdFJhdGlvID0gbmF0dXJhbFdpZHRoIC8gbmF0dXJhbEhlaWdodDtcbiAgICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgaWYgKGlzOTBEZWdyZWVzUm90YXRlZCkge1xuICAgICAgICB2YXIgX3JlZjMgPSBbbWF4SGVpZ2h0LCBtYXhXaWR0aF07XG4gICAgICAgIG1heFdpZHRoID0gX3JlZjNbMF07XG4gICAgICAgIG1heEhlaWdodCA9IF9yZWYzWzFdO1xuICAgICAgICB2YXIgX3JlZjQgPSBbbWluSGVpZ2h0LCBtaW5XaWR0aF07XG4gICAgICAgIG1pbldpZHRoID0gX3JlZjRbMF07XG4gICAgICAgIG1pbkhlaWdodCA9IF9yZWY0WzFdO1xuICAgICAgICB2YXIgX3JlZjUgPSBbaGVpZ2h0LCB3aWR0aF07XG4gICAgICAgIHdpZHRoID0gX3JlZjVbMF07XG4gICAgICAgIGhlaWdodCA9IF9yZWY1WzFdO1xuICAgICAgfVxuICAgICAgaWYgKHJlc2l6YWJsZSkge1xuICAgICAgICBhc3BlY3RSYXRpbyA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgfVxuICAgICAgdmFyIF9nZXRBZGp1c3RlZFNpemVzID0gZ2V0QWRqdXN0ZWRTaXplcyh7XG4gICAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcbiAgICAgICAgd2lkdGg6IG1heFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IG1heEhlaWdodFxuICAgICAgfSwgJ2NvbnRhaW4nKTtcbiAgICAgIG1heFdpZHRoID0gX2dldEFkanVzdGVkU2l6ZXMud2lkdGg7XG4gICAgICBtYXhIZWlnaHQgPSBfZ2V0QWRqdXN0ZWRTaXplcy5oZWlnaHQ7XG4gICAgICB2YXIgX2dldEFkanVzdGVkU2l6ZXMyID0gZ2V0QWRqdXN0ZWRTaXplcyh7XG4gICAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyxcbiAgICAgICAgd2lkdGg6IG1pbldpZHRoLFxuICAgICAgICBoZWlnaHQ6IG1pbkhlaWdodFxuICAgICAgfSwgJ2NvdmVyJyk7XG4gICAgICBtaW5XaWR0aCA9IF9nZXRBZGp1c3RlZFNpemVzMi53aWR0aDtcbiAgICAgIG1pbkhlaWdodCA9IF9nZXRBZGp1c3RlZFNpemVzMi5oZWlnaHQ7XG4gICAgICBpZiAocmVzaXphYmxlKSB7XG4gICAgICAgIHZhciBfZ2V0QWRqdXN0ZWRTaXplczMgPSBnZXRBZGp1c3RlZFNpemVzKHtcbiAgICAgICAgICBhc3BlY3RSYXRpbzogYXNwZWN0UmF0aW8sXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0sIG9wdGlvbnMucmVzaXplKTtcbiAgICAgICAgd2lkdGggPSBfZ2V0QWRqdXN0ZWRTaXplczMud2lkdGg7XG4gICAgICAgIGhlaWdodCA9IF9nZXRBZGp1c3RlZFNpemVzMy5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2dldEFkanVzdGVkU2l6ZXM0ID0gZ2V0QWRqdXN0ZWRTaXplcyh7XG4gICAgICAgICAgYXNwZWN0UmF0aW86IGFzcGVjdFJhdGlvLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9nZXRBZGp1c3RlZFNpemVzNCR3aSA9IF9nZXRBZGp1c3RlZFNpemVzNC53aWR0aDtcbiAgICAgICAgd2lkdGggPSBfZ2V0QWRqdXN0ZWRTaXplczQkd2kgPT09IHZvaWQgMCA/IG5hdHVyYWxXaWR0aCA6IF9nZXRBZGp1c3RlZFNpemVzNCR3aTtcbiAgICAgICAgdmFyIF9nZXRBZGp1c3RlZFNpemVzNCRoZSA9IF9nZXRBZGp1c3RlZFNpemVzNC5oZWlnaHQ7XG4gICAgICAgIGhlaWdodCA9IF9nZXRBZGp1c3RlZFNpemVzNCRoZSA9PT0gdm9pZCAwID8gbmF0dXJhbEhlaWdodCA6IF9nZXRBZGp1c3RlZFNpemVzNCRoZTtcbiAgICAgIH1cbiAgICAgIHdpZHRoID0gTWF0aC5mbG9vcihub3JtYWxpemVEZWNpbWFsTnVtYmVyKE1hdGgubWluKE1hdGgubWF4KHdpZHRoLCBtaW5XaWR0aCksIG1heFdpZHRoKSkpO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5mbG9vcihub3JtYWxpemVEZWNpbWFsTnVtYmVyKE1hdGgubWluKE1hdGgubWF4KGhlaWdodCwgbWluSGVpZ2h0KSwgbWF4SGVpZ2h0KSkpO1xuICAgICAgdmFyIGRlc3RYID0gLXdpZHRoIC8gMjtcbiAgICAgIHZhciBkZXN0WSA9IC1oZWlnaHQgLyAyO1xuICAgICAgdmFyIGRlc3RXaWR0aCA9IHdpZHRoO1xuICAgICAgdmFyIGRlc3RIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICBpZiAocmVzaXphYmxlKSB7XG4gICAgICAgIHZhciBzcmNYID0gMDtcbiAgICAgICAgdmFyIHNyY1kgPSAwO1xuICAgICAgICB2YXIgc3JjV2lkdGggPSBuYXR1cmFsV2lkdGg7XG4gICAgICAgIHZhciBzcmNIZWlnaHQgPSBuYXR1cmFsSGVpZ2h0O1xuICAgICAgICB2YXIgX2dldEFkanVzdGVkU2l6ZXM1ID0gZ2V0QWRqdXN0ZWRTaXplcyh7XG4gICAgICAgICAgYXNwZWN0UmF0aW86IGFzcGVjdFJhdGlvLFxuICAgICAgICAgIHdpZHRoOiBuYXR1cmFsV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBuYXR1cmFsSGVpZ2h0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjb250YWluOiAnY292ZXInLFxuICAgICAgICAgIGNvdmVyOiAnY29udGFpbidcbiAgICAgICAgfVtvcHRpb25zLnJlc2l6ZV0pO1xuICAgICAgICBzcmNXaWR0aCA9IF9nZXRBZGp1c3RlZFNpemVzNS53aWR0aDtcbiAgICAgICAgc3JjSGVpZ2h0ID0gX2dldEFkanVzdGVkU2l6ZXM1LmhlaWdodDtcbiAgICAgICAgc3JjWCA9IChuYXR1cmFsV2lkdGggLSBzcmNXaWR0aCkgLyAyO1xuICAgICAgICBzcmNZID0gKG5hdHVyYWxIZWlnaHQgLSBzcmNIZWlnaHQpIC8gMjtcbiAgICAgICAgcGFyYW1zLnB1c2goc3JjWCwgc3JjWSwgc3JjV2lkdGgsIHNyY0hlaWdodCk7XG4gICAgICB9XG4gICAgICBwYXJhbXMucHVzaChkZXN0WCwgZGVzdFksIGRlc3RXaWR0aCwgZGVzdEhlaWdodCk7XG4gICAgICBpZiAoaXM5MERlZ3JlZXNSb3RhdGVkKSB7XG4gICAgICAgIHZhciBfcmVmNiA9IFtoZWlnaHQsIHdpZHRoXTtcbiAgICAgICAgd2lkdGggPSBfcmVmNlswXTtcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjZbMV07XG4gICAgICB9XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBpZiAoIWlzSW1hZ2VUeXBlKG9wdGlvbnMubWltZVR5cGUpKSB7XG4gICAgICAgIG9wdGlvbnMubWltZVR5cGUgPSBmaWxlLnR5cGU7XG4gICAgICB9XG4gICAgICB2YXIgZmlsbFN0eWxlID0gJ3RyYW5zcGFyZW50JztcblxuICAgICAgLy8gQ29udmVydHMgUE5HIGZpbGVzIG92ZXIgdGhlIGBjb252ZXJ0U2l6ZWAgdG8gSlBFR3MuXG4gICAgICBpZiAoZmlsZS5zaXplID4gb3B0aW9ucy5jb252ZXJ0U2l6ZSAmJiBvcHRpb25zLmNvbnZlcnRUeXBlcy5pbmRleE9mKG9wdGlvbnMubWltZVR5cGUpID49IDApIHtcbiAgICAgICAgb3B0aW9ucy5taW1lVHlwZSA9ICdpbWFnZS9qcGVnJztcbiAgICAgIH1cbiAgICAgIHZhciBpc0pQRUdJbWFnZSA9IG9wdGlvbnMubWltZVR5cGUgPT09ICdpbWFnZS9qcGVnJztcbiAgICAgIGlmIChpc0pQRUdJbWFnZSkge1xuICAgICAgICBmaWxsU3R5bGUgPSAnI2ZmZic7XG4gICAgICB9XG5cbiAgICAgIC8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGZpbGwgY29sb3IgKCMwMDAsIGJsYWNrKVxuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgaWYgKG9wdGlvbnMuYmVmb3JlRHJhdykge1xuICAgICAgICBvcHRpb25zLmJlZm9yZURyYXcuY2FsbCh0aGlzLCBjb250ZXh0LCBjYW52YXMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICBjb250ZXh0LnJvdGF0ZShyb3RhdGUgKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAgIGNvbnRleHQuc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UuYXBwbHkoY29udGV4dCwgW2ltYWdlXS5jb25jYXQocGFyYW1zKSk7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIGlmIChvcHRpb25zLmRyZXcpIHtcbiAgICAgICAgb3B0aW9ucy5kcmV3LmNhbGwodGhpcywgY29udGV4dCwgY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soYmxvYikge1xuICAgICAgICBpZiAoIV90aGlzMy5hYm9ydGVkKSB7XG4gICAgICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5kb25lKHtcbiAgICAgICAgICAgICAgbmF0dXJhbFdpZHRoOiBuYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICAgIG5hdHVyYWxIZWlnaHQ6IG5hdHVyYWxIZWlnaHQsXG4gICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChibG9iICYmIGlzSlBFR0ltYWdlICYmIG9wdGlvbnMucmV0YWluRXhpZiAmJiBfdGhpczMuZXhpZiAmJiBfdGhpczMuZXhpZi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRvbmUodG9CbG9iKGFycmF5QnVmZmVyVG9EYXRhVVJMKGluc2VydEV4aWYoYXJyYXlCdWZmZXIsIF90aGlzMy5leGlmKSwgb3B0aW9ucy5taW1lVHlwZSkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoYmxvYi5hcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICBibG9iLmFycmF5QnVmZmVyKCkudGhlbihuZXh0KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLmZhaWwobmV3IEVycm9yKCdGYWlsZWQgdG8gcmVhZCB0aGUgY29tcHJlc3NlZCBpbWFnZSB3aXRoIEJsb2IuYXJyYXlCdWZmZXIoKS4nKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgIF90aGlzMy5yZWFkZXIgPSByZWFkZXI7XG4gICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoX3JlZjcpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gX3JlZjcudGFyZ2V0O1xuICAgICAgICAgICAgICAgIG5leHQodGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJlYWRlci5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzMy5mYWlsKG5ldyBFcnJvcignQWJvcnRlZCB0byByZWFkIHRoZSBjb21wcmVzc2VkIGltYWdlIHdpdGggRmlsZVJlYWRlci4nKSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzMy5mYWlsKG5ldyBFcnJvcignRmFpbGVkIHRvIHJlYWQgdGhlIGNvbXByZXNzZWQgaW1hZ2Ugd2l0aCBGaWxlUmVhZGVyLicpKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczMucmVhZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb25lKGJsb2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChjYW52YXMudG9CbG9iKSB7XG4gICAgICAgIGNhbnZhcy50b0Jsb2IoY2FsbGJhY2ssIG9wdGlvbnMubWltZVR5cGUsIG9wdGlvbnMucXVhbGl0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayh0b0Jsb2IoY2FudmFzLnRvRGF0YVVSTChvcHRpb25zLm1pbWVUeXBlLCBvcHRpb25zLnF1YWxpdHkpKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9uZShfcmVmOCkge1xuICAgICAgdmFyIG5hdHVyYWxXaWR0aCA9IF9yZWY4Lm5hdHVyYWxXaWR0aCxcbiAgICAgICAgbmF0dXJhbEhlaWdodCA9IF9yZWY4Lm5hdHVyYWxIZWlnaHQsXG4gICAgICAgIHJlc3VsdCA9IF9yZWY4LnJlc3VsdDtcbiAgICAgIHZhciBmaWxlID0gdGhpcy5maWxlLFxuICAgICAgICBpbWFnZSA9IHRoaXMuaW1hZ2UsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAoVVJMICYmIGltYWdlLnNyYy5pbmRleE9mKCdibG9iOicpID09PSAwKSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoaW1hZ2Uuc3JjKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgLy8gUmV0dXJucyBvcmlnaW5hbCBmaWxlIGlmIHRoZSByZXN1bHQgaXMgZ3JlYXRlciB0aGFuIGl0IGFuZCB3aXRob3V0IHNpemUgcmVsYXRlZCBvcHRpb25zXG4gICAgICAgIGlmIChvcHRpb25zLnN0cmljdCAmJiAhb3B0aW9ucy5yZXRhaW5FeGlmICYmIHJlc3VsdC5zaXplID4gZmlsZS5zaXplICYmIG9wdGlvbnMubWltZVR5cGUgPT09IGZpbGUudHlwZSAmJiAhKG9wdGlvbnMud2lkdGggPiBuYXR1cmFsV2lkdGggfHwgb3B0aW9ucy5oZWlnaHQgPiBuYXR1cmFsSGVpZ2h0IHx8IG9wdGlvbnMubWluV2lkdGggPiBuYXR1cmFsV2lkdGggfHwgb3B0aW9ucy5taW5IZWlnaHQgPiBuYXR1cmFsSGVpZ2h0IHx8IG9wdGlvbnMubWF4V2lkdGggPCBuYXR1cmFsV2lkdGggfHwgb3B0aW9ucy5tYXhIZWlnaHQgPCBuYXR1cmFsSGVpZ2h0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZpbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgIHJlc3VsdC5sYXN0TW9kaWZpZWQgPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgICByZXN1bHQubGFzdE1vZGlmaWVkRGF0ZSA9IGRhdGU7XG4gICAgICAgICAgcmVzdWx0Lm5hbWUgPSBmaWxlLm5hbWU7XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBleHRlbnNpb24gdG8gbWF0Y2ggaXRzIHR5cGVcbiAgICAgICAgICBpZiAocmVzdWx0Lm5hbWUgJiYgcmVzdWx0LnR5cGUgIT09IGZpbGUudHlwZSkge1xuICAgICAgICAgICAgcmVzdWx0Lm5hbWUgPSByZXN1bHQubmFtZS5yZXBsYWNlKFJFR0VYUF9FWFRFTlNJT04sIGltYWdlVHlwZVRvRXh0ZW5zaW9uKHJlc3VsdC50eXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm5zIG9yaWdpbmFsIGZpbGUgaWYgdGhlIHJlc3VsdCBpcyBudWxsIGluIHNvbWUgY2FzZXMuXG4gICAgICAgIHJlc3VsdCA9IGZpbGU7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIGlmIChvcHRpb25zLnN1Y2Nlc3MpIHtcbiAgICAgICAgb3B0aW9ucy5zdWNjZXNzLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmFpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYWlsKGVycikge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAob3B0aW9ucy5lcnJvcikge1xuICAgICAgICBvcHRpb25zLmVycm9yLmNhbGwodGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWJvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICBpZiAoIXRoaXMuYWJvcnRlZCkge1xuICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5yZWFkZXIpIHtcbiAgICAgICAgICB0aGlzLnJlYWRlci5hYm9ydCgpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgdGhpcy5pbWFnZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuaW1hZ2Uub25hYm9ydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZmFpbChuZXcgRXJyb3IoJ1RoZSBjb21wcmVzc2lvbiBwcm9jZXNzIGhhcyBiZWVuIGFib3J0ZWQuJykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBubyBjb25mbGljdCBjb21wcmVzc29yIGNsYXNzLlxuICAgICAqIEByZXR1cm5zIHtDb21wcmVzc29yfSBUaGUgY29tcHJlc3NvciBjbGFzcy5cbiAgICAgKi9cbiAgfV0sIFt7XG4gICAga2V5OiBcIm5vQ29uZmxpY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIHdpbmRvdy5Db21wcmVzc29yID0gQW5vdGhlckNvbXByZXNzb3I7XG4gICAgICByZXR1cm4gQ29tcHJlc3NvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBuZXcgZGVmYXVsdCBvcHRpb25zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldERlZmF1bHRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERlZmF1bHRzKG9wdGlvbnMpIHtcbiAgICAgIF9leHRlbmRzKERFRkFVTFRTLCBvcHRpb25zKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbXByZXNzb3I7XG59KCk7XG5cbmV4cG9ydCB7IENvbXByZXNzb3IgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/compressorjs/dist/compressor.esm.js\n");

/***/ })

};
;